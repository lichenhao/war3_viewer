import{u as ee}from"./arrayunique.min.js";import{W as te,a as re}from"./map.min2.js";import{B as k}from"./tokenstream.min.js";import{c as G,d as q,V as X,e as z,G as ie,f as se,g as P,n as ne,h as ae}from"./handler.min.js";import{M as oe}from"./model.min.js";import{d as fe}from"./math.min.js";import{W as le}from"./file.min2.js";import{W as ce}from"./file.min3.js";class Ae{groundHeight=0;waterHeight=0;mapEdge=0;ramp=0;blight=0;water=0;boundary=0;groundTexture=0;cliffVariation=0;groundVariation=0;cliffTexture=0;layerHeight=0;load(e){this.groundHeight=(e.readInt16()-8192)/512;const r=e.readInt16();this.waterHeight=((r&16383)-8192)/512,this.mapEdge=r&16384;const t=e.readUint8();this.ramp=t&16,this.blight=t&32,this.water=t&64,this.boundary=t&128,this.groundTexture=t&15;const n=e.readUint8();this.cliffVariation=(n&224)>>>5,this.groundVariation=n&31;const i=e.readUint8();this.cliffTexture=(i&240)>>>4,this.layerHeight=i&15}save(e){e.writeInt16(this.groundHeight*512+8192),e.writeInt16(this.waterHeight*512+8192+this.mapEdge<<14),e.writeUint8(this.ramp<<4|this.blight<<5|this.water<<6|this.boundary<<7|this.groundTexture),e.writeUint8(this.cliffVariation<<5|this.groundVariation),e.writeUint8((this.cliffTexture<<4)+this.layerHeight)}}class ue{version=0;tileset="A";haveCustomTileset=0;groundTilesets=[];cliffTilesets=[];mapSize=new Int32Array(2);centerOffset=new Float32Array(2);corners=[];load(e){const r=new k(e);if(r.readBinary(4)==="W3E!"){this.version=r.readInt32(),this.tileset=r.readBinary(1),this.haveCustomTileset=r.readInt32();for(let t=0,n=r.readInt32();t<n;t++)this.groundTilesets[t]=r.readBinary(4);for(let t=0,n=r.readInt32();t<n;t++)this.cliffTilesets[t]=r.readBinary(4);r.readInt32Array(this.mapSize),r.readFloat32Array(this.centerOffset);for(let t=0,n=this.mapSize[1];t<n;t++){this.corners[t]=[];for(let i=0,s=this.mapSize[0];i<s;i++){const o=new Ae;o.load(r),this.corners[t][i]=o}}}}save(){const e=new k(new ArrayBuffer(this.getByteLength()));e.writeBinary("W3E!"),e.writeInt32(this.version),e.writeBinary(this.tileset),e.writeInt32(this.haveCustomTileset),e.writeUint32(this.groundTilesets.length);for(const r of this.groundTilesets)e.writeBinary(r);e.writeUint32(this.cliffTilesets.length);for(const r of this.cliffTilesets)e.writeBinary(r);e.writeInt32Array(this.mapSize),e.writeFloat32Array(this.centerOffset);for(const r of this.corners)for(const t of r)t.save(e);return e.uint8array}getByteLength(){return 37+this.groundTilesets.length*4+this.cliffTilesets.length*4+this.mapSize[0]*this.mapSize[1]*7}}const he={AAAB:1,AAAC:1,AABA:1,AABB:2,AABC:0,AACA:1,AACB:0,AACC:1,ABAA:1,ABAB:1,ABAC:0,ABBA:2,ABBB:1,ABBC:0,ABCA:0,ABCB:0,ABCC:0,ACAA:1,ACAB:0,ACAC:1,ACBA:0,ACBB:0,ACBC:0,ACCA:1,ACCB:0,ACCC:1,BAAA:1,BAAB:1,BAAC:0,BABA:1,BABB:1,BABC:0,BACA:0,BACB:0,BACC:0,BBAA:1,BBAB:1,BBAC:0,BBBA:1,BBCA:0,BCAA:0,BCAB:0,BCAC:0,BCBA:0,BCCA:0,CAAA:1,CAAB:0,CAAC:1,CABA:0,CABB:0,CABC:0,CACA:1,CACB:0,CACC:1,CBAA:0,CBAB:0,CBAC:0,CBBA:0,CBCA:0,CCAA:1,CCAB:0,CCAC:1,CCBA:0,CCCA:1},de={AAAB:2,AAAC:1,AABA:1,AABB:3,AABC:0,AACA:1,AACB:0,AACC:3,ABAA:1,ABAB:2,ABAC:0,ABBA:3,ABBB:0,ABBC:0,ABCA:0,ABCB:0,ABCC:0,ACAA:1,ACAB:0,ACAC:2,ACBA:0,ACBB:0,ACBC:0,ACCA:3,ACCB:0,ACCC:1,BAAA:1,BAAB:3,BAAC:0,BABA:2,BABB:0,BABC:0,BACA:0,BACB:0,BACC:0,BBAA:3,BBAB:1,BBAC:0,BBBA:1,BBCA:0,BCAA:0,BCAB:0,BCAC:0,BCBA:0,BCCA:0,CAAA:1,CAAB:0,CAAC:3,CABA:0,CABB:0,CABC:0,CACA:2,CACB:0,CACC:1,CBAA:0,CBAB:0,CBAC:0,CBBA:0,CBCA:0,CCAA:3,CCAB:0,CCAC:1,CCBA:0,CCCA:1};function Be(B,e,r){return B==="Cliffs"?Math.min(r,he[e]):Math.min(r,de[e])}class me{map;vertexBuffer;faceBuffer;normalsOffset;uvsOffset;elements;locationAndTextureBuffer;texturesOffset;instances;vao;constructor(e,r,t,n,i){const s=e.viewer.gl,o=e.viewer.webgl,l=o.extensions.ANGLE_instanced_arrays,c=o.extensions.OES_vertex_array_object,w=new oe;w.load(r);const T=w.geosets[0],A=T.vertices,h=T.normals,d=T.uvSets[0],m=T.faces,R=A.byteLength,y=R+h.byteLength;let D=null;const x=i.attribs;c&&(D=c.createVertexArrayOES(),c.bindVertexArrayOES(D));const S=s.createBuffer();s.bindBuffer(s.ARRAY_BUFFER,S),s.bufferData(s.ARRAY_BUFFER,y+d.byteLength,s.STATIC_DRAW),s.bufferSubData(s.ARRAY_BUFFER,0,A),s.bufferSubData(s.ARRAY_BUFFER,R,h),s.bufferSubData(s.ARRAY_BUFFER,y,d),c&&(s.vertexAttribPointer(x.a_position,3,s.FLOAT,!1,0,0),s.enableVertexAttribArray(x.a_position),s.vertexAttribPointer(x.a_normal,3,s.FLOAT,!1,0,R),s.enableVertexAttribArray(x.a_normal),s.vertexAttribPointer(x.a_uv,2,s.FLOAT,!1,0,y),s.enableVertexAttribArray(x.a_uv));const p=t.length*4,L=s.createBuffer();s.bindBuffer(s.ARRAY_BUFFER,L),s.bufferData(s.ARRAY_BUFFER,p+n.length,s.STATIC_DRAW),s.bufferSubData(s.ARRAY_BUFFER,0,new Float32Array(t)),s.bufferSubData(s.ARRAY_BUFFER,p,new Uint8Array(n)),c&&(s.vertexAttribPointer(x.a_instancePosition,3,s.FLOAT,!1,0,0),s.enableVertexAttribArray(x.a_instancePosition),l.vertexAttribDivisorANGLE(x.a_instancePosition,1),s.vertexAttribPointer(x.a_instanceTexture,1,s.UNSIGNED_BYTE,!1,0,p),s.enableVertexAttribArray(x.a_instanceTexture),l.vertexAttribDivisorANGLE(x.a_instanceTexture,1));const E=s.createBuffer();s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,E),s.bufferData(s.ELEMENT_ARRAY_BUFFER,m,s.STATIC_DRAW),c&&c.bindVertexArrayOES(null),this.map=e,this.vertexBuffer=S,this.faceBuffer=E,this.normalsOffset=R,this.uvsOffset=y,this.elements=m.length,this.locationAndTextureBuffer=L,this.texturesOffset=p,this.instances=t.length/3,this.vao=D}render(e){const r=this.map.viewer,t=r.gl,n=r.webgl,i=n.extensions.ANGLE_instanced_arrays,s=n.extensions.OES_vertex_array_object,o=e.attribs;s?s.bindVertexArrayOES(this.vao):(t.bindBuffer(t.ARRAY_BUFFER,this.locationAndTextureBuffer),t.vertexAttribPointer(o.a_instancePosition,3,t.FLOAT,!1,0,0),t.vertexAttribPointer(o.a_instanceTexture,1,t.UNSIGNED_BYTE,!1,0,this.texturesOffset),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.vertexAttribPointer(o.a_position,3,t.FLOAT,!1,0,0),t.vertexAttribPointer(o.a_normal,3,t.FLOAT,!1,0,this.normalsOffset),t.vertexAttribPointer(o.a_uv,2,t.FLOAT,!1,0,this.uvsOffset),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.faceBuffer)),i.drawElementsInstancedANGLE(t.TRIANGLES,this.elements,t.UNSIGNED_SHORT,0,this.instances),s&&s.bindVertexArrayOES(null)}}function we(B,e){return B.sequence.rarity-e.sequence.rarity}function xe(B,e){const r=[];for(let t=0,n=e.length;t<n;t++){const i=e[t];i.name.split("-")[0].replace(/\d/g,"").trim().toLowerCase()===B&&r.push({sequence:i,index:t})}return r}function Te(B,e){const r=xe(B,e);let t,n;for(r.sort(we),t=0,n=r.length;t<n;t++){const c=r[t].sequence.rarity;if(c===0)break;if(Math.random()*10>c)return r[t]}const i=r.length-t,s=t+Math.floor(Math.random()*i);return r[s]}function be(B){const r=B.model.sequences,t=Te("stand",r);t&&B.setSequence(t.index)}class J{instance;state=0;constructor(e,r){this.instance=r.addInstance(),this.instance.setScene(e.worldScene)}update(){(this.instance.sequenceEnded||this.instance.sequence===-1)&&this.state===0&&be(this.instance)}}const Z=G();class ge extends J{row;constructor(e,r,t,n){super(e,r);const i=this.instance;i.move(n.location),i.rotateLocal(q(z(),X,n.angle)),i.scale(n.scale),i.setTeamColor(n.player),i.setScene(e.worldScene),t&&(Z[2]=t.number("moveHeight"),i.move(Z),i.setVertexColor([t.number("red")/255,t.number("green")/255,t.number("blue")/255,1]),i.uniformScale(t.number("modelScale"))),this.instance=i,this.row=t}}class Ce extends J{row;constructor(e,r,t,n){super(e,r);const i=this.instance;i.move(n.location),i.rotateLocal(q(z(),X,n.angle)),i.scale(n.scale),i.setScene(e.worldScene),this.instance=i,this.row=t}}const Y=G();class Re{instance;row;constructor(e,r,t,n){const i=e.centerOffset,s=r.addInstance();Y[0]=n.location[0]*128+i[0]+128,Y[1]=n.location[1]*128+i[1]+128,s.move(Y),s.rotateLocal(q(z(),X,fe(t.number("fixedRot")))),s.setScene(e.worldScene),this.instance=s,this.row=t}}const W=G(),$=G();class Ue{viewer;map;pathSolver;buildVersion=0;solverParams={tileset:"a"};worldScene;waterIndex=0;waterIncreasePerFrame=0;waterHeightOffset=0;waterTextures=[];maxDeepColor=new Float32Array(4);minDeepColor=new Float32Array(4);maxShallowColor=new Float32Array(4);minShallowColor=new Float32Array(4);anyReady=!1;terrainReady=!1;cliffsReady=!1;doodads=[];terrainDoodads=[];doodadsReady=!1;units=[];unitsReady=!1;tilesetTextures=[];cliffTextures=[];cliffModels=[];corners=[];centerOffset=new Float32Array(2);mapSize=new Int32Array(2);tilesets=[];blightTextureIndex=-1;cliffTilesets=[];columns=0;rows=0;vertexBuffer=null;faceBuffer=null;instanceBuffer=null;textureBuffer=null;variationBuffer=null;waterBuffer=null;heightMap=null;waterHeightMap=null;cliffHeightMap=null;constructor(e,r){this.viewer=e,this.worldScene=e.addScene(),this.map=new te,this.map.load(r,!0),this.loadMapInformation(),this.pathSolver=(n,i)=>{if(typeof n=="string"){const s=n.replace(/\//g,"\\"),o=this.map.get(s);return o?o.arrayBuffer():e.wc3PathSolver(n,i)}return n},this.loadTerrainCliffsAndWater();const t=this.map.readModifications();this.applyModificationFile(e.doodadsData,e.doodadMetaData,t.w3d),this.applyModificationFile(e.doodadsData,e.destructableMetaData,t.w3b),this.applyModificationFile(e.unitsData,e.unitMetaData,t.w3u),this.applyModificationFile(e.unitsData,e.unitMetaData,t.w3t),this.loadDoodadsAndDestructibles(),this.loadUnitsAndItems()}die(){this.worldScene.detach()}load(e){return this.viewer.load(e,this.pathSolver,this.solverParams)}loadMapInformation(){const e=this.map.get("war3map.w3i");if(!e){console.warn("Attempted to load war3map.w3i but it is not there. Using default tileset A.");return}const r=new re;try{r.load(e.bytes())}catch{console.warn("Failed to correctly parse the map information file")}this.solverParams.tileset=r.tileset.toLowerCase(),this.buildVersion=r.getBuildVersion(),this.buildVersion>131&&(this.solverParams.reforged=!0)}async loadTerrainCliffsAndWater(){const e=this.map.get("war3map.w3e");if(!e){console.warn("Attempted to load war3map.w3e, but it is not there.");return}const r=new ue;try{r.load(e.bytes())}catch(f){console.warn(`Failed to load war3map.w3e: ${f}`);return}const t=this.viewer,n=r.centerOffset,i=r.mapSize;this.corners=r.corners,this.centerOffset.set(n),this.mapSize.set(i),this.worldScene.grid=new ie(n[0],n[1],i[0]*128-128,i[1]*128-128,2048,2048);const s=this.solverParams.reforged?".dds":".blp",o=r.tileset,l=[],c=[],w=[];for(const f of r.groundTilesets){const u=t.terrainData.getRow(f);this.tilesets.push(u),l.push(this.load(`${u.string("dir")}\\${u.string("file")}${s}`))}const T={A:"Ashen",B:"Barrens",C:"Felwood",D:"Cave",F:"Lordf",G:"Dungeon",I:"Ice",J:"DRuins",K:"Citadel",L:"Lords",N:"North",O:"Outland",Q:"VillageFall",V:"Village",W:"Lordw",X:"Village",Y:"Village",Z:"Ruins"};this.blightTextureIndex=this.tilesetTextures.length,l.push(this.load(`TerrainArt\\Blight\\${T[o]}_Blight${s}`));for(const f of r.cliffTilesets){const u=t.cliffTypesData.getRow(f);this.cliffTilesets.push(u),c.push(this.load(`${u.string("texDir")}\\${u.string("texFile")}${s}`))}const A=t.waterData.getRow(`${o}Sha`);this.waterHeightOffset=A.number("height"),this.waterIncreasePerFrame=A.number("texRate")/60,this.waterTextures.length=0,this.maxDeepColor.set([A.number("Dmax_R"),A.number("Dmax_G"),A.number("Dmax_B"),A.number("Dmax_A")]),this.minDeepColor.set([A.number("Dmin_R"),A.number("Dmin_G"),A.number("Dmin_B"),A.number("Dmin_A")]),this.maxShallowColor.set([A.number("Smax_R"),A.number("Smax_G"),A.number("Smax_B"),A.number("Smax_A")]),this.minShallowColor.set([A.number("Smin_R"),A.number("Smin_G"),A.number("Smin_B"),A.number("Smin_A")]);for(let f=0,u=A.number("numTex");f<u;f++)w.push(this.load(`${A.string("texFile")}${f<10?"0":""}${f}${s}`));this.tilesetTextures=await Promise.all(l),this.cliffTextures=await Promise.all(c),this.waterTextures=await Promise.all(w);const h=r.corners,[d,m]=this.mapSize,R=(d-1)*(m-1),y=new Float32Array(d*m),D=new Float32Array(d*m),x=new Float32Array(d*m),S=new Uint8Array(R*4),p=new Uint8Array(R*4),L=new Uint8Array(R);let E=0;const U={};this.columns=d-1,this.rows=m-1;for(let f=0;f<m;f++)for(let u=0;u<d;u++){const g=h[f][u],I=f*d+u;if(y[I]=g.groundHeight,D[I]=g.groundHeight+g.layerHeight-2,x[I]=g.waterHeight,f<m-1&&u<d-1){if(L[E]=this.isWater(u,f),this.isCliff(u,f)){const v=g.layerHeight,M=h[f][u+1].layerHeight,N=h[f+1][u].layerHeight,O=h[f+1][u+1].layerHeight,F=Math.min(v,M,N,O),b=this.cliffFileName(v,M,N,O,F);if(b!=="AAAA"){let C=g.cliffTexture;C===15&&(C=1);const _=this.cliffTilesets[C].string("cliffModelDir"),H=`Doodads\\Terrain\\${_}\\${_}${b}${Be(_,b,g.cliffVariation)}.mdx`;U[H]||(U[H]={locations:[],textures:[]}),U[H].locations.push((u+1)*128+n[0],f*128+n[1],(F-2)*128),U[H].textures.push(C)}}else{const v=this.cornerTexture(u,f),M=this.cornerTexture(u+1,f),N=this.cornerTexture(u,f+1),O=this.cornerTexture(u+1,f+1),F=ee([v,M,N,O]).sort();let b=F[0];S[E*4]=b+1,p[E*4]=this.getVariation(b,g.groundVariation),F.shift();for(let C=0,j=F.length;C<j;C++){let _=0;b=F[C],M===b&&(_|=1),v===b&&(_|=2),O===b&&(_|=4),N===b&&(_|=8),S[E*4+1+C]=b+1,p[E*4+1+C]=_}}E+=1}}const a=this.viewer.gl,V=this.viewer.webgl;this.vertexBuffer=a.createBuffer(),a.bindBuffer(a.ARRAY_BUFFER,this.vertexBuffer),a.bufferData(a.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,1,1]),a.STATIC_DRAW),this.faceBuffer=a.createBuffer(),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,this.faceBuffer),a.bufferData(a.ELEMENT_ARRAY_BUFFER,new Uint8Array([0,1,2,1,3,2]),a.STATIC_DRAW),this.cliffHeightMap=a.createTexture(),a.bindTexture(a.TEXTURE_2D,this.cliffHeightMap),V.setTextureMode(a.CLAMP_TO_EDGE,a.CLAMP_TO_EDGE,a.NEAREST,a.NEAREST),a.texImage2D(a.TEXTURE_2D,0,a.ALPHA,d,m,0,a.ALPHA,a.FLOAT,y),this.heightMap=a.createTexture(),a.bindTexture(a.TEXTURE_2D,this.heightMap),V.setTextureMode(a.CLAMP_TO_EDGE,a.CLAMP_TO_EDGE,a.NEAREST,a.NEAREST),a.texImage2D(a.TEXTURE_2D,0,a.ALPHA,d,m,0,a.ALPHA,a.FLOAT,D),this.waterHeightMap=a.createTexture(),a.bindTexture(a.TEXTURE_2D,this.waterHeightMap),V.setTextureMode(a.CLAMP_TO_EDGE,a.CLAMP_TO_EDGE,a.NEAREST,a.NEAREST),a.texImage2D(a.TEXTURE_2D,0,a.ALPHA,d,m,0,a.ALPHA,a.FLOAT,x),this.instanceBuffer=a.createBuffer(),a.bindBuffer(a.ARRAY_BUFFER,this.instanceBuffer),a.bufferData(a.ARRAY_BUFFER,new Float32Array(R).map((f,u)=>u),a.STATIC_DRAW),this.textureBuffer=a.createBuffer(),a.bindBuffer(a.ARRAY_BUFFER,this.textureBuffer),a.bufferData(a.ARRAY_BUFFER,S,a.STATIC_DRAW),this.variationBuffer=a.createBuffer(),a.bindBuffer(a.ARRAY_BUFFER,this.variationBuffer),a.bufferData(a.ARRAY_BUFFER,p,a.STATIC_DRAW),this.waterBuffer=a.createBuffer(),a.bindBuffer(a.ARRAY_BUFFER,this.waterBuffer),a.bufferData(a.ARRAY_BUFFER,L,a.STATIC_DRAW),this.terrainReady=!0,this.anyReady=!0;const K=t.cliffShader,Q=Object.entries(U).map(async f=>{const u=f[0],{locations:g,textures:I}=f[1],v=await t.loadBaseFile(u,"arrayBuffer");if(v)return new me(this,v.data,g,I,K)}).filter(f=>f);this.cliffModels=await Promise.all(Q),this.cliffsReady=!0}loadDoodadsAndDestructibles(){const e=this.map.get("war3map.doo");if(!e){console.warn("Attempted to load war3map.doo but it is not there");return}const r=new le;try{r.load(e.bytes(),this.buildVersion)}catch(t){console.warn(`Failed to load war3map.doo: ${t}`);return}for(const t of r.doodads)try{const n=this.viewer.doodadsData.getRow(t.id);if(n){let i=n.string("file");if(i){const s=n.number("numVar");i.endsWith(".mdl")&&(i=i.slice(0,-4));let o=i;i+=".mdx",s>1&&(o+=Math.min(t.variation,s-1)),o+=".mdx";const l=this.map.get(o)||this.map.get(i);let c;l?c=this.load(l.name):c=this.load(o),c.then(w=>{w&&this.doodads.push(new Ce(this,w,n,t))})}else console.log("Unknown doodad ID",t.id,t)}}catch(n){console.warn(`Failed to load doodad/destructible ID ${t.id}: ${n}`)}for(const t of r.terrainDoodads)try{const n=this.viewer.doodadsData.getRow(t.id);this.load(`${n.string("file")}.mdx`).then(i=>{i&&this.terrainDoodads.push(new Re(this,i,n,t))})}catch(n){console.warn(`Failed to load cliff/terrain doodad ID ${t.id}: ${n}`)}this.doodadsReady=!0,this.anyReady=!0}loadUnitsAndItems(){const e=this.map.get("war3mapUnits.doo");if(!e){console.warn("Attempted to load war3mapUnits.doo but it is not there");return}const r=new ce;try{r.load(e.bytes(),this.buildVersion)}catch(t){console.warn(`Failed to load war3mapUnits.doo: ${t}`);return}for(const t of r.units)try{let n,i;t.id==="sloc"?i="Objects\\StartLocation\\StartLocation.mdx":(n=this.viewer.unitsData.getRow(t.id),n&&(i=n.string("file"),i&&(i.endsWith(".mdl")&&(i=i.slice(0,-4)),i+=".mdx"))),i?this.load(i).then(s=>{s&&this.units.push(new ge(this,s,n,t))}):console.log("Unknown unit ID",t.id,t)}catch(n){console.warn(`Failed to load unit/item ID ${t.id}: ${n}`)}this.unitsReady=!0,this.anyReady=!0}update(){if(this.anyReady){this.waterIndex+=this.waterIncreasePerFrame,this.waterIndex>=this.waterTextures.length&&(this.waterIndex=0);for(const e of this.doodads)e.update();for(const e of this.units)e.update()}}render(){if(this.anyReady){const e=this.worldScene;e.startFrame(),this.renderGround(),this.renderCliffs(),e.renderOpaque(),this.renderWater(),e.renderTranslucent()}}renderGround(){if(this.terrainReady){const e=this.viewer.gl,r=this.viewer.webgl,t=r.extensions.ANGLE_instanced_arrays,n=this.viewer.groundShader,i=n.uniforms,s=n.attribs,o=this.tilesetTextures,l=s.a_InstanceID,c=s.a_position,w=s.a_textures,T=s.a_variations,A=o.length;e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),r.useShader(n),e.uniformMatrix4fv(i.u_VP,!1,this.worldScene.camera.viewProjectionMatrix),e.uniform2fv(i.u_offset,this.centerOffset),e.uniform2f(i.u_size,this.columns,this.rows),e.uniform1i(i.u_heightMap,15),e.activeTexture(e.TEXTURE15),e.bindTexture(e.TEXTURE_2D,this.heightMap),e.bindBuffer(e.ARRAY_BUFFER,this.vertexBuffer),e.vertexAttribPointer(c,2,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,this.instanceBuffer),e.vertexAttribPointer(l,1,e.FLOAT,!1,0,0),t.vertexAttribDivisorANGLE(l,1),e.bindBuffer(e.ARRAY_BUFFER,this.textureBuffer),e.vertexAttribPointer(w,4,e.UNSIGNED_BYTE,!1,0,0),t.vertexAttribDivisorANGLE(w,1),e.bindBuffer(e.ARRAY_BUFFER,this.variationBuffer),e.vertexAttribPointer(T,4,e.UNSIGNED_BYTE,!1,0,0),t.vertexAttribDivisorANGLE(T,1),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.faceBuffer),e.uniform1f(i.u_baseTileset,0);for(let h=0,d=Math.min(A,15);h<d;h++){const m=o[h].width>o[h].height?1:0;e.uniform1f(i[`u_extended[${h}]`],m),e.uniform1i(i[`u_tilesets[${h}]`],h),r.bindTexture(o[h],h)}if(t.drawElementsInstancedANGLE(e.TRIANGLES,6,e.UNSIGNED_BYTE,0,this.rows*this.columns),A>15){e.uniform1f(i.u_baseTileset,15);for(let h=0,d=A-15;h<d;h++){const m=o[h+15].width>o[h+15].height?1:0;e.uniform1f(i[`u_extended[${h}]`],m),r.bindTexture(o[h+15],h)}t.drawElementsInstancedANGLE(e.TRIANGLES,6,e.UNSIGNED_BYTE,0,this.rows*this.columns)}t.vertexAttribDivisorANGLE(w,0),t.vertexAttribDivisorANGLE(T,0),t.vertexAttribDivisorANGLE(l,0)}}renderWater(){if(this.terrainReady){const e=this.viewer.gl,r=this.viewer.webgl,t=r.extensions.ANGLE_instanced_arrays,n=this.viewer.waterShader,i=n.uniforms,s=n.attribs,o=s.a_InstanceID,l=s.a_position,c=s.a_isWater;e.depthMask(!1),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),r.useShader(n),e.uniformMatrix4fv(i.u_VP,!1,this.worldScene.camera.viewProjectionMatrix),e.uniform2fv(i.u_offset,this.centerOffset),e.uniform2f(i.u_size,this.columns,this.rows),e.uniform1i(i.u_heightMap,0),e.uniform1i(i.u_waterHeightMap,1),e.uniform1i(i.u_waterTexture,2),e.uniform1f(i.u_offsetHeight,this.waterHeightOffset),e.uniform4fv(i.u_maxDeepColor,this.maxDeepColor),e.uniform4fv(i.u_minDeepColor,this.minDeepColor),e.uniform4fv(i.u_maxShallowColor,this.maxShallowColor),e.uniform4fv(i.u_minShallowColor,this.minShallowColor),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,this.heightMap),e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,this.waterHeightMap),r.bindTexture(this.waterTextures[this.waterIndex|0],2),e.bindBuffer(e.ARRAY_BUFFER,this.vertexBuffer),e.vertexAttribPointer(l,2,e.FLOAT,!1,8,0),e.bindBuffer(e.ARRAY_BUFFER,this.instanceBuffer),e.vertexAttribPointer(o,1,e.FLOAT,!1,4,0),t.vertexAttribDivisorANGLE(o,1),e.bindBuffer(e.ARRAY_BUFFER,this.waterBuffer),e.vertexAttribPointer(c,1,e.UNSIGNED_BYTE,!1,1,0),t.vertexAttribDivisorANGLE(c,1),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.faceBuffer),t.drawElementsInstancedANGLE(e.TRIANGLES,6,e.UNSIGNED_BYTE,0,this.rows*this.columns),t.vertexAttribDivisorANGLE(c,0),t.vertexAttribDivisorANGLE(o,0)}}renderCliffs(){if(this.cliffsReady){const e=this.viewer.gl,r=this.viewer.webgl,t=r.extensions.ANGLE_instanced_arrays,n=r.extensions.OES_vertex_array_object,i=this.viewer.cliffShader,s=i.attribs,o=i.uniforms;e.disable(e.BLEND),i.use(),e.uniformMatrix4fv(o.u_VP,!1,this.worldScene.camera.viewProjectionMatrix),e.uniform1i(o.u_heightMap,0),e.uniform2f(o.u_pixel,1/(this.columns+1),1/(this.rows+1)),e.uniform2fv(o.u_centerOffset,this.centerOffset),e.uniform1i(o.u_texture1,1),e.uniform1i(o.u_texture2,2),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,this.cliffHeightMap),e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,this.cliffTextures[0].webglResource),this.cliffTextures.length>1&&(e.activeTexture(e.TEXTURE2),e.bindTexture(e.TEXTURE_2D,this.cliffTextures[1].webglResource)),n||(t.vertexAttribDivisorANGLE(s.a_instancePosition,1),t.vertexAttribDivisorANGLE(s.a_instanceTexture,1));for(const l of this.cliffModels)l.render(i);n||(t.vertexAttribDivisorANGLE(s.a_instancePosition,0),t.vertexAttribDivisorANGLE(s.a_instanceTexture,0))}}cliffFileName(e,r,t,n,i){return String.fromCharCode(65+e-i)+String.fromCharCode(65+t-i)+String.fromCharCode(65+n-i)+String.fromCharCode(65+r-i)}getVariation(e,r){const t=this.tilesetTextures[e];return t.width>t.height?r<16?16+r:r===16?15:0:r===0?0:15}isCliff(e,r){if(e<1||e>this.columns-1||r<1||r>this.rows-1)return!1;const t=this.corners,n=t[r][e].layerHeight,i=t[r][e+1].layerHeight,s=t[r+1][e].layerHeight,o=t[r+1][e+1].layerHeight;return n!==i||n!==s||n!==o}isWater(e,r){const t=this.corners;return t[r][e].water||t[r][e+1].water||t[r+1][e].water||t[r+1][e+1].water}cliffGroundIndex(e){const r=this.cliffTilesets[e].string("groundTile"),t=this.tilesets;for(let n=0,i=t.length;n<i;n++)if(t[n].string("tileID")===r)return n;return 0}cornerTexture(e,r){const t=this.corners,n=this.columns,i=this.rows;for(let o=-1;o<1;o++)for(let l=-1;l<1;l++)if(e+l>0&&e+l<n-1&&r+o>0&&r+o<i-1&&this.isCliff(e+l,r+o)){let c=t[r+o][e+l].cliffTexture;return c===15&&(c=1),this.cliffGroundIndex(c)}const s=t[r][e];return s.blight?this.blightTextureIndex:s.groundTexture}applyModificationFile(e,r,t){t&&(this.applyModificationTable(e,r,t.originalTable),this.applyModificationTable(e,r,t.customTable))}applyModificationTable(e,r,t){for(const n of t.objects){let i;n.newId!==""?(i=e.getRow(n.newId),i||(i=new se,i.map=Object.assign({},e.getRow(n.oldId).map),e.setRow(n.newId,i))):i=e.getRow(n.oldId);for(const s of n.modifications){const o=r.getRow(s.id);o?i.set(o.string("field"),s.value):console.warn("Unknown modification ID",s)}}}groundNormal(e,r,t){const n=this.centerOffset,i=this.mapSize;r=(r-n[0])/128,t=(t-n[1])/128;const s=r|0,o=t|0;if(s>=0&&s<i[0]-1&&o>=0&&o<i[1]-1){const l=this.corners,c=l[o][s].groundHeight,w=l[o][s+1].groundHeight,T=l[o+1][s].groundHeight,A=l[o+1][s+1].groundHeight,h=r-s,d=t-o;h+d<1?(P(W,1,0,w-c),P($,0,1,T-c)):(P(W,-1,0,A-T),P($,0,1,A-w)),ne(e,ae(e,W,$))}else P(e,0,0,1);return e}}export{Ue as W};
