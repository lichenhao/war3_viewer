import{u as R}from"./arrayunique.min.js";import{b as L}from"./path.min.js";import{A as K,I as E,S as P,G as S,C as v,T,k as y,l as V,E as k,d as w,L as C,m as q,e as F,f as b,B as x,n as N,o as O,p as M,P as W,q as U,r as B,R as H,s as D,t as Z}from"./model.min.js";function z(e,t,n){if(n===-1){const s=e.model.sequences;for(let r=0,i=s.length;r<i;r++){const o=s[r].interval;if(t>=o[0]&&t<=o[1])return r}}else{const s=e.model.globalSequences[n];if(t>=0&&t<=s)return n}return-1}function X(e,t,n,s){let r=-1/0;for(let i=0,o=t.length;i<o;i++){const a=t[i];e.assertWarning(a>=0,`Track ${i} has a negative frame ${a}`),a===r?e.addWarning(`Track ${i} has the same frame ${a} as track ${i-1}`):a<r&&e.addSevere(`Track ${i} at frame ${a} is lower than the track before it at ${r}`);const l=z(e,a,n);l!==-1?s[l].push(i):a!==0&&t.length>1&&(n===-1?e.addUnused(`Track ${i} at frame ${a} is not in any sequence`):e.addUnused(`Track ${i} at frame ${a} is not in global sequence ${n}`)),r=a}}function J(e,t,n){return n===-1?`sequence "${e.model.sequences[t].name}"`:`global sequence ${n}`}const Q=.001;function Y(e,t,n){let s=0;for(let r=0,i=e.length;r<i;r++){const o=e[r],a=Math.abs(o-t[r]),l=Math.abs(o-n[r]);a>s&&(s=a),l>s&&(s=l)}return s}function _(e,t){for(let n=0,s=e.length;n<s;n++)if(e[n]!==t[n])return!1;return!0}function j(e,t,n,s,r){const{globalSequenceId:i,interpolationType:o,values:a}=s;let l;i===-1?l=e.model.sequences[n].interval[0]:l=0;const f=t[0],c=t[t.length-1],d=r[f];if(o!==E.DontInterp&&d!==l){const h=a[f],u=a[c];_(h,u)||e.addSevere(`Missing opening track for ${J(e,n,i)} at frame ${l} where it is needed`)}if(t.length>2){let h=a[t[0]],u=a[t[1]];for(let p=2,I=t.length;p<I;p++){const A=a[t[p]],m=t[p-1],$=Y(h,u,A);$===0?e.addUnused(`Track ${m} at frame ${r[m]} has exactly the same value as tracks ${m-1} and ${m+1}`):$<Q&&e.addUnused(`Track ${m} at frame ${r[m]} has roughly the same value as tracks ${m-1} and ${m+1}`),h=u,u=A}}}function ee(e,t){let n;t instanceof K?(e.assertWarning(t.frames.length>0,"Zero tracks"),n=t.frames):(e.assertError(t.tracks.length>0,"Zero tracks"),n=t.tracks);const s=t.globalSequenceId,r=[];if(s===-1){e.assertWarning(e.model.sequences.length>0,"This animation exists, but the model has no sequences");for(let i=0,o=e.model.sequences.length;i<o;i++)r.push([])}else if(re(e,e.model.globalSequences,s,"global sequence"))r[s]=[];else return;if(X(e,n,s,r),t instanceof K)for(let i=0,o=r.length;i<o;i++){const a=r[i];a&&a.length>1&&j(e,a,i,t,n)}}function ne(e,t,n){return e>=t&&e<=n}const me=new Set(["attack","birth","cinematic","death","decay","dissipate","morph","portrait","sleep","spell","stand","walk","ready"]),he=new Set([1,2,11,21,31,32,33,34,35,36,37]),G=new Map([["KMTF","Texture ID"],["KMTA","Alpha"],["KMTE","Emissive Gain"],["KFC3","Fresnel Color"],["KFCA","Fresnel Opacity"],["KFTC","Fresnel Team Color"],["KTAT","Translation"],["KTAR","Rotation"],["KTAS","Scaling"],["KGAO","Alpha"],["KGAC","Color"],["KGTR","Translation"],["KGRT","Rotation"],["KGSC","Scaling"],["KLAS","Attenuation Start"],["KLAE","Attenuation End"],["KLAC","Color"],["KLAI","Intensity"],["KLBI","Ambient Intensity"],["KLBC","Ambient Color"],["KLAV","Visibility"],["KATV","Visibility"],["KPEE","Emission Rate"],["KPEG","Gravity"],["KPLN","Longitude"],["KPLT","Latitude"],["KPEL","Lifespan"],["KPES","Speed"],["KPEV","Visibility"],["KP2E","Emission Rate"],["KP2G","Gravity"],["KP2L","Latitude"],["KP2R","Variation"],["KP2N","Length"],["KP2W","Width"],["KP2S","Speed"],["KP2V","Visibility"],["KPPA","Alpha"],["KPPC","Color"],["KPPE","EmissionRate"],["KPPL","LifeSpan"],["KPPS","Speed"],["KPPV","Visibility"],["KRHA","Height Above"],["KRHB","Height Below"],["KRAL","Alpha"],["KRCO","Color"],["KRTX","Texture Slot"],["KRVS","Visibility"],["KCTR","Translation"],["KTTR","Rotation"],["KCRL","Target Translation"]]);function pe(e,t){for(const n of e.animations)if(n.name===t)return!0;return!1}function te(e){return e instanceof k?"Extent":e instanceof P?"Sequence":typeof e=="number"?"GlobalSequence":e instanceof T?"Texture":e instanceof w?"Material":e instanceof C?"Layer":e instanceof q?"TextureAnimation":e instanceof F?"Geoset":e instanceof b?"GeosetAnimation":e instanceof x?"Bone":e instanceof N?"Light":e instanceof O?"Helper":e instanceof M?"Attachment":e instanceof W?"ParticleEmitter":e instanceof U?"ParticleEmitter2":e instanceof B?"ParticleEmitterPopcorn":e instanceof H?"RibbonEmitter":e instanceof D?"EventObject":e instanceof v?"Camera":e instanceof Z?"CollisionShape":e instanceof y?"FaceEffect":e instanceof K?G.get(e.name):(console.warn("Unknown object type",e),"Unknown")}function ge(e,t){let n=te(e);return!(e instanceof K)&&!(e instanceof k)&&(n+=` ${t}`),(e instanceof P||e instanceof S||e instanceof v)&&(n+=` - "${e.name}"`),(e instanceof T||e instanceof y)&&(e.path.length&&(n+=` - "${L(e.path)}"`),e instanceof T&&(e.replaceableId===1?n+=" - Team color":e.replaceableId===2?n+=" - Team glow":e.replaceableId>0&&(n+=` - Replaceable ID ${e.replaceableId}`))),n}function se(e,t,n){const s=t.length;if(s){const r=t[0]instanceof V,i=t[0]instanceof S;for(let o=0;o<s;o++){const a=t[o];if(e.push(a,o),n&&n(e,a,o),r&&se(e,a.animations,oe),i){const l=a,f=l.objectId,c=l.parentId;e.assertError(c===-1||ae(e,c),`Invalid parent ${c}`),e.assertError(f!==c,"Same object and parent")}e.pop()}}}function ie(e,t,n,s){if(n>=0&&n<t.length)return e.addReference(t[n]),t[n];e.addError(`Invalid ${s} ${n}`)}function re(e,t,n,s){return ie(e,t,n,s)!==void 0}function de(e){for(const t of e.animations)if(t.name==="KMTF")return R(t.values.map(n=>n[0]));return[e.textureId]}function g(e,t,n,s){const r=e.objects[n];if(s&&e.assertError(ne(n,0,255),`Vertex ${t}: References bone ${n} but there can only be 256 bones in an HD model`),r)if(!(r instanceof x))e.addSevere(`Vertex ${t}: Attached to "${r.name}" which is not a bone`);else{const i=e.boneUsageMap.get(n)||0;e.boneUsageMap.set(n,i+1)}else e.addError(`Vertex ${t}: Attached to object ${n} which does not exist`)}function Ke(e,t){if(e.model.version>800&&t.skin.length){e.assertWarning(t.vertexGroups.length===0,"This geoset has both skin/weights and vertex groups");const n=t.skin;for(let s=0,r=n.length/8;s<r;s++){const i=s*8,o=n[i],a=n[i+1],l=n[i+2],f=n[i+3],c=n[i+4],d=n[i+5],h=n[i+6],u=n[i+7];c>0&&g(e,s,o,!0),d>0&&g(e,s,a,!0),h>0&&g(e,s,l,!0),u>0&&g(e,s,f,!0);const p=c+d+h+u;p===0?e.addSevere(`Vertex ${s}: Not attached to anything`):p!==255&&e.addSevere(`Vertex ${s}: The weights are not normalized to 1`)}}else if(e.model.bones.length){const n=t.vertexGroups,s=t.matrixGroups,r=t.matrixIndices,i=[];for(let o=0,a=s.length,l=0;o<a;o++)i.push(r.subarray(l,l+s[o])),l+=s[o];for(let o=0,a=n.length;o<a;o++){const l=i[n[o]];if(l)for(const f of l)g(e,o,f,!1);else{const f=n[o];f===255?e.addSevere(`Vertex ${o}: Not attached to anything`):e.addSevere(`Vertex ${o}: Attached to vertex group ${f} which does not exist`)}}}}function ae(e,t){for(const n of e.objects)if(n.objectId===t)return!0;return!1}function oe(e,t){const n=t.name,s=t.interpolationType;e.assertWarning(n!=="KP2R","Using a variation animation."),e.assertWarning(n!=="KP2G","Using a gravity animation."),e.assertWarning(G.get(n)!=="Visibility"||s===E.DontInterp,"Interpolation type not set to None"),ee(e,t)}function le(e){const t=e.nodes;for(let n=t.length-1;n>=0;n--){const s=t[n];s.type==="node"&&(s.errors||s.severe||s.warnings||s.unused||s.uses!==void 0&&!s.uses?le(s):t.splice(n,1))}}function Te(e,t){for(const n of e.animations)if(n.name===t)return n}function Ae(e,t){e.push(t,0);const{max:n,min:s}=t;(n[0]-s[0]<0||n[1]-s[1]<0||n[2]-s[2]<0)&&e.addWarning("Negative extents"),e.pop()}export{se as a,ie as b,Ke as c,re as d,Te as e,ee as f,ge as g,pe as h,de as i,le as j,te as k,Y as l,he as r,me as s,Ae as t};
