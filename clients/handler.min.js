import{a as wr}from"./tokenstream.min.js";import{i as mt,l as ti,h as ri,b as ii,r as ye,d as si}from"./math.min.js";import{e as ni}from"./path.min.js";import{I as W,U as oi,g as ai,V as li,b as pe,F as je,c as Me,h as Se,H as qe,W as Ve,a as et,M as St,i as ci,j as hi}from"./model.min.js";import{I as ui}from"./file.min.js";import{e as fi}from"./events.min.js";var di=1e-6,ue=typeof Float32Array<"u"?Float32Array:Array;Math.hypot||(Math.hypot=function(){for(var i=0,e=arguments.length;e--;)i+=arguments[e]*arguments[e];return Math.sqrt(i)});function mi(){var i=new ue(9);return ue!=Float32Array&&(i[1]=0,i[2]=0,i[3]=0,i[5]=0,i[6]=0,i[7]=0),i[0]=1,i[4]=1,i[8]=1,i}function Ce(){var i=new ue(16);return ue!=Float32Array&&(i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=0,i[12]=0,i[13]=0,i[14]=0),i[0]=1,i[5]=1,i[10]=1,i[15]=1,i}function zt(i,e){var t=e[0],r=e[1],s=e[2],n=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],f=e[10],d=e[11],m=e[12],v=e[13],p=e[14],b=e[15],g=t*a-r*o,E=t*l-s*o,T=t*c-n*o,_=r*l-s*a,x=r*c-n*a,L=s*c-n*l,F=u*v-h*m,V=u*p-f*m,N=u*b-d*m,k=h*p-f*v,C=h*b-d*v,B=f*b-d*p,R=g*B-E*C+T*k+_*N-x*V+L*F;return R?(R=1/R,i[0]=(a*B-l*C+c*k)*R,i[1]=(s*C-r*B-n*k)*R,i[2]=(v*L-p*x+b*_)*R,i[3]=(f*x-h*L-d*_)*R,i[4]=(l*N-o*B-c*V)*R,i[5]=(t*B-s*N+n*V)*R,i[6]=(p*T-m*L-b*E)*R,i[7]=(u*L-f*T+d*E)*R,i[8]=(o*C-a*N+c*F)*R,i[9]=(r*N-t*C-n*F)*R,i[10]=(m*x-v*T+b*g)*R,i[11]=(h*T-u*x-d*g)*R,i[12]=(a*V-o*k-l*F)*R,i[13]=(t*k-r*V+s*F)*R,i[14]=(v*E-m*_-p*g)*R,i[15]=(u*_-h*E+f*g)*R,i):null}function vi(i,e,t){var r=e[0],s=e[1],n=e[2],o=e[3],a=e[4],l=e[5],c=e[6],u=e[7],h=e[8],f=e[9],d=e[10],m=e[11],v=e[12],p=e[13],b=e[14],g=e[15],E=t[0],T=t[1],_=t[2],x=t[3];return i[0]=E*r+T*a+_*h+x*v,i[1]=E*s+T*l+_*f+x*p,i[2]=E*n+T*c+_*d+x*b,i[3]=E*o+T*u+_*m+x*g,E=t[4],T=t[5],_=t[6],x=t[7],i[4]=E*r+T*a+_*h+x*v,i[5]=E*s+T*l+_*f+x*p,i[6]=E*n+T*c+_*d+x*b,i[7]=E*o+T*u+_*m+x*g,E=t[8],T=t[9],_=t[10],x=t[11],i[8]=E*r+T*a+_*h+x*v,i[9]=E*s+T*l+_*f+x*p,i[10]=E*n+T*c+_*d+x*b,i[11]=E*o+T*u+_*m+x*g,E=t[12],T=t[13],_=t[14],x=t[15],i[12]=E*r+T*a+_*h+x*v,i[13]=E*s+T*l+_*f+x*p,i[14]=E*n+T*c+_*d+x*b,i[15]=E*o+T*u+_*m+x*g,i}function pi(i,e,t){var r=t[0],s=t[1],n=t[2],o,a,l,c,u,h,f,d,m,v,p,b;return e===i?(i[12]=e[0]*r+e[4]*s+e[8]*n+e[12],i[13]=e[1]*r+e[5]*s+e[9]*n+e[13],i[14]=e[2]*r+e[6]*s+e[10]*n+e[14],i[15]=e[3]*r+e[7]*s+e[11]*n+e[15]):(o=e[0],a=e[1],l=e[2],c=e[3],u=e[4],h=e[5],f=e[6],d=e[7],m=e[8],v=e[9],p=e[10],b=e[11],i[0]=o,i[1]=a,i[2]=l,i[3]=c,i[4]=u,i[5]=h,i[6]=f,i[7]=d,i[8]=m,i[9]=v,i[10]=p,i[11]=b,i[12]=o*r+u*s+m*n+e[12],i[13]=a*r+h*s+v*n+e[13],i[14]=l*r+f*s+p*n+e[14],i[15]=c*r+d*s+b*n+e[15]),i}function qt(i,e,t,r){var s=e[0],n=e[1],o=e[2],a=e[3],l=s+s,c=n+n,u=o+o,h=s*l,f=s*c,d=s*u,m=n*c,v=n*u,p=o*u,b=a*l,g=a*c,E=a*u,T=r[0],_=r[1],x=r[2];return i[0]=(1-(m+p))*T,i[1]=(f+E)*T,i[2]=(d-g)*T,i[3]=0,i[4]=(f-E)*_,i[5]=(1-(h+p))*_,i[6]=(v+b)*_,i[7]=0,i[8]=(d+g)*x,i[9]=(v-b)*x,i[10]=(1-(h+m))*x,i[11]=0,i[12]=t[0],i[13]=t[1],i[14]=t[2],i[15]=1,i}function bi(i,e,t,r,s){var n=e[0],o=e[1],a=e[2],l=e[3],c=n+n,u=o+o,h=a+a,f=n*c,d=n*u,m=n*h,v=o*u,p=o*h,b=a*h,g=l*c,E=l*u,T=l*h,_=r[0],x=r[1],L=r[2],F=s[0],V=s[1],N=s[2],k=(1-(v+b))*_,C=(d+T)*_,B=(m-E)*_,R=(d-T)*x,w=(1-(f+b))*x,U=(p+g)*x,y=(m+E)*L,I=(p-g)*L,O=(1-(f+v))*L;return i[0]=k,i[1]=C,i[2]=B,i[3]=0,i[4]=R,i[5]=w,i[6]=U,i[7]=0,i[8]=y,i[9]=I,i[10]=O,i[11]=0,i[12]=t[0]+F-(k*F+R*V+y*N),i[13]=t[1]+V-(C*F+w*V+I*N),i[14]=t[2]+N-(B*F+U*V+O*N),i[15]=1,i}function gi(i,e){var t=e[0],r=e[1],s=e[2],n=e[3],o=t+t,a=r+r,l=s+s,c=t*o,u=r*o,h=r*a,f=s*o,d=s*a,m=s*l,v=n*o,p=n*a,b=n*l;return i[0]=1-h-m,i[1]=u+b,i[2]=f-p,i[3]=0,i[4]=u-b,i[5]=1-c-m,i[6]=d+v,i[7]=0,i[8]=f+p,i[9]=d-v,i[10]=1-c-h,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}function xi(i,e,t,r,s){var n=1/Math.tan(e/2),o;return i[0]=n/t,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=n,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=-1,i[12]=0,i[13]=0,i[15]=0,s!=null&&s!==1/0?(o=1/(r-s),i[10]=(s+r)*o,i[14]=2*s*r*o):(i[10]=-1,i[14]=-2*r),i}function _i(i,e,t,r,s,n,o){var a=1/(e-t),l=1/(r-s),c=1/(n-o);return i[0]=-2*a,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=-2*l,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=2*c,i[11]=0,i[12]=(e+t)*a,i[13]=(s+r)*l,i[14]=(o+n)*c,i[15]=1,i}var Lt=vi;function M(){var i=new ue(3);return ue!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),i}function Ti(i){var e=i[0],t=i[1],r=i[2];return Math.hypot(e,t,r)}function q(i,e,t){var r=new ue(3);return r[0]=i,r[1]=e,r[2]=t,r}function oe(i,e){return i[0]=e[0],i[1]=e[1],i[2]=e[2],i}function _e(i,e,t,r){return i[0]=e,i[1]=t,i[2]=r,i}function Te(i,e,t){return i[0]=e[0]+t[0],i[1]=e[1]+t[1],i[2]=e[2]+t[2],i}function Ei(i,e,t){return i[0]=e[0]-t[0],i[1]=e[1]-t[1],i[2]=e[2]-t[2],i}function wi(i,e,t){return i[0]=e[0]*t[0],i[1]=e[1]*t[1],i[2]=e[2]*t[2],i}function vt(i,e,t){return i[0]=e[0]*t,i[1]=e[1]*t,i[2]=e[2]*t,i}function Si(i,e){return i[0]=-e[0],i[1]=-e[1],i[2]=-e[2],i}function yt(i,e){var t=e[0],r=e[1],s=e[2],n=t*t+r*r+s*s;return n>0&&(n=1/Math.sqrt(n)),i[0]=e[0]*n,i[1]=e[1]*n,i[2]=e[2]*n,i}function yi(i,e){return i[0]*e[0]+i[1]*e[1]+i[2]*e[2]}function Ke(i,e,t){var r=e[0],s=e[1],n=e[2],o=t[0],a=t[1],l=t[2];return i[0]=s*l-n*a,i[1]=n*o-r*l,i[2]=r*a-s*o,i}function Ai(i,e,t,r){var s=e[0],n=e[1],o=e[2];return i[0]=s+r*(t[0]-s),i[1]=n+r*(t[1]-n),i[2]=o+r*(t[2]-o),i}function Ri(i,e,t,r,s,n){var o=n*n,a=o*(2*n-3)+1,l=o*(n-2)+n,c=o*(n-1),u=o*(3-2*n);return i[0]=e[0]*a+t[0]*l+r[0]*c+s[0]*u,i[1]=e[1]*a+t[1]*l+r[1]*c+s[1]*u,i[2]=e[2]*a+t[2]*l+r[2]*c+s[2]*u,i}function Ci(i,e,t,r,s,n){var o=1-n,a=o*o,l=n*n,c=a*o,u=3*n*a,h=3*l*o,f=l*n;return i[0]=e[0]*c+t[0]*u+r[0]*h+s[0]*f,i[1]=e[1]*c+t[1]*u+r[1]*h+s[1]*f,i[2]=e[2]*c+t[2]*u+r[2]*h+s[2]*f,i}function we(i,e,t){var r=e[0],s=e[1],n=e[2],o=t[3]*r+t[7]*s+t[11]*n+t[15];return o=o||1,i[0]=(t[0]*r+t[4]*s+t[8]*n+t[12])/o,i[1]=(t[1]*r+t[5]*s+t[9]*n+t[13])/o,i[2]=(t[2]*r+t[6]*s+t[10]*n+t[14])/o,i}function he(i,e,t){var r=t[0],s=t[1],n=t[2],o=t[3],a=e[0],l=e[1],c=e[2],u=s*c-n*l,h=n*a-r*c,f=r*l-s*a,d=s*f-n*h,m=n*u-r*f,v=r*h-s*u,p=o*2;return u*=p,h*=p,f*=p,d*=2,m*=2,v*=2,i[0]=a+u+d,i[1]=l+h+m,i[2]=c+f+v,i}var Mi=Ei,$e=wi,Li=Ti;(function(){var i=M();return function(e,t,r,s,n,o){var a,l;for(t||(t=3),r||(r=0),s?l=Math.min(s*t+r,e.length):l=e.length,a=r;a<l;a+=t)i[0]=e[a],i[1]=e[a+1],i[2]=e[a+2],n(i,i,o),e[a]=i[0],e[a+1]=i[1],e[a+2]=i[2];return e}})();function xe(){var i=new ue(4);return ue!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0,i[3]=0),i}function Ii(i,e,t,r){var s=new ue(4);return s[0]=i,s[1]=e,s[2]=t,s[3]=r,s}function Pi(i,e){return i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i}function Fi(i,e,t,r,s){return i[0]=e,i[1]=t,i[2]=r,i[3]=s,i}function Oi(i,e){var t=e[0],r=e[1],s=e[2],n=e[3],o=t*t+r*r+s*s+n*n;return o>0&&(o=1/Math.sqrt(o)),i[0]=t*o,i[1]=r*o,i[2]=s*o,i[3]=n*o,i}function Di(i,e,t){var r=e[0],s=e[1],n=e[2],o=e[3];return i[0]=t[0]*r+t[4]*s+t[8]*n+t[12]*o,i[1]=t[1]*r+t[5]*s+t[9]*n+t[13]*o,i[2]=t[2]*r+t[6]*s+t[10]*n+t[14]*o,i[3]=t[3]*r+t[7]*s+t[11]*n+t[15]*o,i}(function(){var i=xe();return function(e,t,r,s,n,o){var a,l;for(t||(t=4),r||(r=0),s?l=Math.min(s*t+r,e.length):l=e.length,a=r;a<l;a+=t)i[0]=e[a],i[1]=e[a+1],i[2]=e[a+2],i[3]=e[a+3],n(i,i,o),e[a]=i[0],e[a+1]=i[1],e[a+2]=i[2],e[a+3]=i[3];return e}})();function $(){var i=new ue(4);return ue!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),i[3]=1,i}function It(i){return i[0]=0,i[1]=0,i[2]=0,i[3]=1,i}function Ne(i,e,t){t=t*.5;var r=Math.sin(t);return i[0]=r*e[0],i[1]=r*e[1],i[2]=r*e[2],i[3]=Math.cos(t),i}function Ni(i,e,t){var r=e[0],s=e[1],n=e[2],o=e[3],a=t[0],l=t[1],c=t[2],u=t[3];return i[0]=r*u+o*a+s*c-n*l,i[1]=s*u+o*l+n*a-r*c,i[2]=n*u+o*c+r*l-s*a,i[3]=o*u-r*a-s*l-n*c,i}function Sr(i,e,t){t*=.5;var r=e[0],s=e[1],n=e[2],o=e[3],a=Math.sin(t),l=Math.cos(t);return i[0]=r*l+o*a,i[1]=s*l+n*a,i[2]=n*l-s*a,i[3]=o*l-r*a,i}function Pt(i,e,t){t*=.5;var r=e[0],s=e[1],n=e[2],o=e[3],a=Math.sin(t),l=Math.cos(t);return i[0]=r*l-n*a,i[1]=s*l+o*a,i[2]=n*l+r*a,i[3]=o*l-s*a,i}function yr(i,e,t){t*=.5;var r=e[0],s=e[1],n=e[2],o=e[3],a=Math.sin(t),l=Math.cos(t);return i[0]=r*l+s*a,i[1]=s*l-r*a,i[2]=n*l+o*a,i[3]=o*l-n*a,i}function dt(i,e,t,r){var s=e[0],n=e[1],o=e[2],a=e[3],l=t[0],c=t[1],u=t[2],h=t[3],f,d,m,v,p;return d=s*l+n*c+o*u+a*h,d<0&&(d=-d,l=-l,c=-c,u=-u,h=-h),1-d>di?(f=Math.acos(d),m=Math.sin(f),v=Math.sin((1-r)*f)/m,p=Math.sin(r*f)/m):(v=1-r,p=r),i[0]=v*s+p*l,i[1]=v*n+p*c,i[2]=v*o+p*u,i[3]=v*a+p*h,i}function Ar(i,e){return i[0]=-e[0],i[1]=-e[1],i[2]=-e[2],i[3]=e[3],i}function Vi(i,e){var t=e[0]+e[4]+e[8],r;if(t>0)r=Math.sqrt(t+1),i[3]=.5*r,r=.5/r,i[0]=(e[5]-e[7])*r,i[1]=(e[6]-e[2])*r,i[2]=(e[1]-e[3])*r;else{var s=0;e[4]>e[0]&&(s=1),e[8]>e[s*3+s]&&(s=2);var n=(s+1)%3,o=(s+2)%3;r=Math.sqrt(e[s*3+s]-e[n*3+n]-e[o*3+o]+1),i[s]=.5*r,r=.5/r,i[3]=(e[n*3+o]-e[o*3+n])*r,i[n]=(e[n*3+s]+e[s*3+n])*r,i[o]=(e[o*3+s]+e[s*3+o])*r}return i}var Bi=Ii,Be=Pi,re=Ni,Rr=Oi;(function(){var i=M(),e=q(1,0,0),t=q(0,1,0);return function(r,s,n){var o=yi(s,n);return o<-.999999?(Ke(i,e,s),Li(i)<1e-6&&Ke(i,t,s),yt(i,i),Ne(r,i,Math.PI),r):o>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(Ke(i,s,n),r[0]=i[0],r[1]=i[1],r[2]=i[2],r[3]=1+o,Rr(r,r))}})();var Ui=(function(){var i=$(),e=$();return function(t,r,s,n,o,a){return dt(i,r,o,a),dt(e,s,n,a),dt(t,i,e,2*a*(1-a)),t}})();(function(){var i=mi();return function(e,t,r,s){return i[0]=r[0],i[3]=r[1],i[6]=r[2],i[1]=s[0],i[4]=s[1],i[7]=s[2],i[2]=-t[0],i[5]=-t[1],i[8]=-t[2],Rr(e,Vi(e,i))}})();const Ft=q(1,0,0),Cr=q(0,1,0),Ze=q(0,0,1),Ue=M(),Ot=q(1,1,1);Bi(0,0,0,0);const Dt=$(),ge=xe();function Xt(i,e,t,r){const s=2*(e[0]-r[0])/r[2]-1,n=1-2*(e[1]-r[1])/r[3],o=2*e[2]-1;return Fi(ge,s,n,o,1),Di(ge,ge,t),_e(i,ge[0]/ge[3],ge[1]/ge[3],ge[2]/ge[3]),i}function tt(i,e,t){return i[0]*e+i[1]*t+i[3]}function Mr(i,e,t,r){return i[0]*e+i[1]*t+i[2]*r+i[3]}function Gi(i,e,t,r,s,n){n===-1&&(n=0);for(let o=0;o<6;o++){const a=(n+o)%6;if(Mr(i[a],e,t,r)<=-s)return a}return-1}function ki(i,e,t,r,s,n){n===-1&&(n=0);for(let o=0;o<6;o++){const a=(n+o)%6,l=i[a];if(tt(l,e,r)<0&&tt(l,e,s)<0&&tt(l,t,s)<0&&tt(l,t,r)<0)return a}return-1}function Hi(i){return Math.hypot(i[0],i[1],i[2])}function Le(i,e){const t=Hi(e);i[0]=e[0]/t,i[1]=e[1]/t,i[2]=e[2]/t,i[3]=e[3]/t}function ji(i,e){const t=e[0],r=e[4],s=e[8],n=e[12],o=e[1],a=e[5],l=e[9],c=e[13],u=e[2],h=e[6],f=e[10],d=e[14],m=e[3],v=e[7],p=e[11],b=e[15];let g;g=i[0],g[0]=m+t,g[1]=v+r,g[2]=p+s,g[3]=b+n,g=i[1],g[0]=m-t,g[1]=v-r,g[2]=p-s,g[3]=b-n,g=i[2],g[0]=m-o,g[1]=v-a,g[2]=p-l,g[3]=b-c,g=i[3],g[0]=m+o,g[1]=v+a,g[2]=p+l,g[3]=b+c,g=i[4],g[0]=m+u,g[1]=v+h,g[2]=p+f,g[3]=b+d,g=i[5],g[0]=m-u,g[1]=v-h,g[2]=p-f,g[3]=b-d,Le(i[0],i[0]),Le(i[1],i[1]),Le(i[2],i[2]),Le(i[3],i[3]),Le(i[4],i[4]),Le(i[5],i[5])}const X=M(),Y=M(),te=M();function Lr(i,e,t,r){yt(X,Mi(X,t,e)),yt(Y,Ke(Y,r,X)),Ke(te,Y,X);const s=Y[0]+te[2]+X[1];if(s>0){const n=.5/Math.sqrt(s+1);i[3]=.25/n,i[0]=(te[1]-X[2])*n,i[2]=(X[0]-Y[1])*n,i[1]=(Y[2]-te[0])*n}else if(Y[0]>te[2]&&Y[0]>X[1]){const n=2*Math.sqrt(1+Y[0]-te[2]-X[1]);i[3]=(te[1]-X[2])/n,i[0]=.25*n,i[2]=(te[0]+Y[2])/n,i[1]=(X[0]+Y[1])/n}else if(te[2]>X[1]){const n=2*Math.sqrt(1+te[2]-Y[0]-X[1]);i[3]=(X[0]-Y[1])/n,i[0]=(te[0]+Y[2])/n,i[2]=.25*n,i[1]=(X[2]+te[1])/n}else{const n=2*Math.sqrt(1+X[1]-Y[0]-te[2]);i[3]=(Y[2]-te[0])/n,i[0]=(X[0]+Y[1])/n,i[2]=(X[2]+te[1])/n,i[1]=.25*n}return i}let Ye,Ir,Kt;typeof window=="object"&&(Ye=document.createElement("canvas"),Ir=Ye.getContext("2d"),Kt=document.createElement("canvas"),Kt.getContext("2d"));function zi(i){return new Promise((e,t)=>{const r=URL.createObjectURL(i),s=new Image;s.onload=()=>{e(s)},s.onerror=n=>{t(n)},s.src=r})}function qi(i){return Ye.width=i.width,Ye.height=i.height,Ir.putImageData(i,0,0),Ye.toDataURL()}function Zn(i){const e=new Image;return e.src=qi(i),e}class Xi{buffer;uint8array;index=0;byteLength;bitBuffer=0;bits=0;constructor(e,t,r){const s=wr(e);t=t||0,r=r||s.length,this.buffer=e,this.uint8array=s.subarray(t,t+r),this.byteLength=e.byteLength}peekBits(e){return this.loadBits(e),this.bitBuffer&(1<<e)-1}readBits(e){const t=this.peekBits(e);return this.bitBuffer>>>=e,this.bits-=e,t}skipBits(e){this.loadBits(e),this.bitBuffer>>>=e,this.bits-=e}loadBits(e){for(;this.bits<e;)this.bitBuffer+=this.uint8array[this.index]<<this.bits,this.bits+=8,this.index+=1}}function Ki(i){return i instanceof ArrayBuffer&&(i=new Uint8Array(i)),i instanceof Uint8Array&&i[0]===137&&i[1]===80&&i[2]===78&&i[3]===71&&i[4]===13&&i[5]===10&&i[6]===26&&i[7]===10}function Yi(i){return i instanceof ArrayBuffer&&(i=new Uint8Array(i)),i instanceof Uint8Array&&i[0]===255&&i[1]===216&&i[i.length-2]===255&&i[i.length-1]===217}function Wi(i){return i instanceof ArrayBuffer&&(i=new Uint8Array(i)),i instanceof Uint8Array&&i[0]===71&&i[1]===73&&i[2]===70&&i[3]===56&&(i[4]===55||i[4]===57)&&i[5]===97}function $i(i){return i instanceof ArrayBuffer&&(i=new Uint8Array(i)),i instanceof Uint8Array&&i[0]===82&&i[1]===73&&i[2]===70&&i[3]===70&&i[8]===87&&i[9]===69&&i[10]===66&&i[11]===80}class Zi{rows=[];load(e){if(!e.startsWith("ID"))throw new Error("WrongMagicNumber");const t=this.rows;let r=0,s=0;for(const n of e.split(`
`))if(n[0]!=="B")for(const o of n.split(";")){const a=o[0],l=o.substring(1).trim();let c;a==="X"?r=parseInt(l,10)-1:a==="Y"?s=parseInt(l,10)-1:a==="K"&&(t[s]||(t[s]=[]),l[0]==='"'?c=l.slice(1,-1):c=l,t[s][r]=c)}}save(){const e=this.rows,t=e.length,r=[];let s=0;for(let n=0;n<t;n++){const o=e[n],a=o.length;a>s&&(s=a);let l=!0;for(let c=0;c<a;c++){const u=o[c];if(u!==void 0){let h;typeof u=="string"?h=`"${u}"`:typeof u=="boolean"?u?h="TRUE":h="FALSE":h=`${u}`,l?(l=!1,r.push(`C;X${c+1};Y${n+1};K${h}`)):r.push(`C;X${c+1};K${h}`)}}}return`ID;P\r
B;X${s};Y${t}\r
${r.join(`\r
`)}\r
E`}}function Qi(i,e){return((1<<e)-1)/((1<<i)-1)}const Ji=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(i){return typeof i}:function(i){return i&&typeof Symbol=="function"&&i.constructor===Symbol&&i!==Symbol.prototype?"symbol":typeof i},Ee=(function(){function e(t){this.message="JPEG error: "+t}return e.prototype=new Error,e.prototype.name="JpegError",e.constructor=e,e})(),We=new Uint8Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),rt=4017,it=799,st=3406,nt=2276,ot=1567,at=3784,Ie=5793,lt=2896;function es(i,e){let t=0,r=[],s,n,o=16;for(;o>0&&!i[o-1];)o--;r.push({children:[],index:0});let a=r[0],l;for(s=0;s<o;s++){for(n=0;n<i[s];n++){for(a=r.pop(),a.children[a.index]=e[t];a.index>0;)a=r.pop();for(a.index++,r.push(a);r.length<=s;)r.push(l={children:[],index:0}),a.children[a.index]=l.children,a=l;t++}s+1<o&&(r.push(l={children:[],index:0}),a.children[a.index]=l.children,a=l)}return r[0].children}function pt(i,e,t){return 64*((i.blocksPerLine+1)*e+t)}function ts(i,e,t,r,s,n,o,a,l){const c=t.mcusPerLine,u=t.progressive;let h=e,f=0,d=0;function m(){if(d>0)return d--,f>>d&1;if(f=i[e++],f===255){const S=i[e++];if(S)throw new Ee("unexpected marker "+(f<<8|S).toString(16))}return d=7,f>>>7}function v(S){let A=S;for(;;){if(A=A[m()],typeof A=="number")return A;if((typeof A>"u"?"undefined":Ji(A))!=="object")throw new Ee("invalid huffman sequence")}}function p(S){let A=0;for(;S>0;)A=A<<1|m(),S--;return A}function b(S){if(S===1)return m()===1?1:-1;const A=p(S);return A>=1<<S-1?A:A+(-1<<S)+1}function g(S,A){const G=v(S.huffmanTableDC),ie=G===0?0:b(G);S.blockData[A]=S.pred+=ie;let H=1;for(;H<64;){const Z=v(S.huffmanTableAC),ee=Z&15,Q=Z>>4;if(ee===0){if(Q<15)break;H+=16;continue}H+=Q;const He=We[H];S.blockData[A+He]=b(ee),H++}}function E(S,A){const G=v(S.huffmanTableDC),ie=G===0?0:b(G)<<l;S.blockData[A]=S.pred+=ie}function T(S,A){S.blockData[A]|=m()<<l}let _=0;function x(S,A){if(_>0){_--;return}let G=n,ie=o;for(;G<=ie;){const H=v(S.huffmanTableAC),Z=H&15,ee=H>>4;if(Z===0){if(ee<15){_=p(ee)+(1<<ee)-1;break}G+=16;continue}G+=ee;const Q=We[G];S.blockData[A+Q]=b(Z)*(1<<l),G++}}let L=0,F;function V(S,A){let G=n;const ie=o;let H=0,Z,ee;for(;G<=ie;){const Q=We[G];switch(L){case 0:if(ee=v(S.huffmanTableAC),Z=ee&15,H=ee>>4,Z===0)H<15?(_=p(H)+(1<<H),L=4):(H=16,L=1);else{if(Z!==1)throw new Ee("invalid ACn encoding");F=b(Z),L=H?2:3}continue;case 1:case 2:S.blockData[A+Q]?S.blockData[A+Q]+=m()<<l:(H--,H===0&&(L=L===2?3:0));break;case 3:S.blockData[A+Q]?S.blockData[A+Q]+=m()<<l:(S.blockData[A+Q]=F<<l,L=0);break;case 4:S.blockData[A+Q]&&(S.blockData[A+Q]+=m()<<l);break}G++}L===4&&(_--,_===0&&(L=0))}function N(S,A,G,ie,H){const Z=G/c|0,ee=G%c,Q=Z*S.v+ie,He=ee*S.h+H,ei=pt(S,Q,He);A(S,ei)}function k(S,A,G){const ie=G/S.blocksPerLine|0,H=G%S.blocksPerLine,Z=pt(S,ie,H);A(S,Z)}const C=r.length;let B,R,w,U,y,I;u?n===0?I=a===0?E:T:I=a===0?x:V:I=g;let O=0,D,z;C===1?z=r[0].blocksPerLine*r[0].blocksPerColumn:z=c*t.mcusPerColumn;let ae,fe;for(;O<z;){const S=s?Math.min(z-O,s):z;for(R=0;R<C;R++)r[R].pred=0;if(_=0,C===1)for(B=r[0],y=0;y<S;y++)k(B,I,O),O++;else for(y=0;y<S;y++){for(R=0;R<C;R++)for(B=r[R],ae=B.h,fe=B.v,w=0;w<fe;w++)for(U=0;U<ae;U++)N(B,I,O,w,U);O++}d=0,D=At(i,e),D&&D.invalid&&(e=D.offset);const A=D&&D.marker;if(!A||A<=65280)throw new Ee("marker was not found");if(A>=65488&&A<=65495)e+=2;else break}return D=At(i,e),D&&D.invalid&&(e=D.offset),e-h}function rs(i,e,t){const r=i.quantizationTable,s=i.blockData;let n,o,a,l,c,u,h,f,d,m,v,p,b,g,E,T,_;if(!r)throw new Ee("missing required Quantization Table.");for(let x=0;x<64;x+=8){if(d=s[e+x],m=s[e+x+1],v=s[e+x+2],p=s[e+x+3],b=s[e+x+4],g=s[e+x+5],E=s[e+x+6],T=s[e+x+7],d*=r[x],(m|v|p|b|g|E|T)===0){_=Ie*d+512>>10,t[x]=_,t[x+1]=_,t[x+2]=_,t[x+3]=_,t[x+4]=_,t[x+5]=_,t[x+6]=_,t[x+7]=_;continue}m*=r[x+1],v*=r[x+2],p*=r[x+3],b*=r[x+4],g*=r[x+5],E*=r[x+6],T*=r[x+7],n=Ie*d+128>>8,o=Ie*b+128>>8,a=v,l=E,c=lt*(m-T)+128>>8,f=lt*(m+T)+128>>8,u=p<<4,h=g<<4,n=n+o+1>>1,o=n-o,_=a*at+l*ot+128>>8,a=a*ot-l*at+128>>8,l=_,c=c+h+1>>1,h=c-h,f=f+u+1>>1,u=f-u,n=n+l+1>>1,l=n-l,o=o+a+1>>1,a=o-a,_=c*nt+f*st+2048>>12,c=c*st-f*nt+2048>>12,f=_,_=u*it+h*rt+2048>>12,u=u*rt-h*it+2048>>12,h=_,t[x]=n+f,t[x+7]=n-f,t[x+1]=o+h,t[x+6]=o-h,t[x+2]=a+u,t[x+5]=a-u,t[x+3]=l+c,t[x+4]=l-c}for(let x=0;x<8;++x){if(d=t[x],m=t[x+8],v=t[x+16],p=t[x+24],b=t[x+32],g=t[x+40],E=t[x+48],T=t[x+56],(m|v|p|b|g|E|T)===0){_=Ie*d+8192>>14,_=_<-2040?0:_>=2024?255:_+2056>>4,s[e+x]=_,s[e+x+8]=_,s[e+x+16]=_,s[e+x+24]=_,s[e+x+32]=_,s[e+x+40]=_,s[e+x+48]=_,s[e+x+56]=_;continue}n=Ie*d+2048>>12,o=Ie*b+2048>>12,a=v,l=E,c=lt*(m-T)+2048>>12,f=lt*(m+T)+2048>>12,u=p,h=g,n=(n+o+1>>1)+4112,o=n-o,_=a*at+l*ot+2048>>12,a=a*ot-l*at+2048>>12,l=_,c=c+h+1>>1,h=c-h,f=f+u+1>>1,u=f-u,n=n+l+1>>1,l=n-l,o=o+a+1>>1,a=o-a,_=c*nt+f*st+2048>>12,c=c*st-f*nt+2048>>12,f=_,_=u*it+h*rt+2048>>12,u=u*rt-h*it+2048>>12,h=_,d=n+f,T=n-f,m=o+h,E=o-h,v=a+u,g=a-u,p=l+c,b=l-c,d=d<16?0:d>=4080?255:d>>4,m=m<16?0:m>=4080?255:m>>4,v=v<16?0:v>=4080?255:v>>4,p=p<16?0:p>=4080?255:p>>4,b=b<16?0:b>=4080?255:b>>4,g=g<16?0:g>=4080?255:g>>4,E=E<16?0:E>=4080?255:E>>4,T=T<16?0:T>=4080?255:T>>4,s[e+x]=d,s[e+x+8]=m,s[e+x+16]=v,s[e+x+24]=p,s[e+x+32]=b,s[e+x+40]=g,s[e+x+48]=E,s[e+x+56]=T}}function is(i,e){const t=e.blocksPerLine,r=e.blocksPerColumn,s=new Int16Array(64);for(let n=0;n<r;n++)for(let o=0;o<t;o++){const a=pt(e,n,o);rs(e,a,s)}return e.blockData}function At(i,e,t){function r(l){return i[l]<<8|i[l+1]}const s=i.length-1;let n=t<e?t:e;if(e>=s)return null;const o=r(e);if(o>=65472&&o<=65534)return{invalid:null,marker:o,offset:e};let a=r(n);for(;!(a>=65472&&a<=65534);){if(++n>=s)return null;a=r(n)}return{invalid:o.toString(16),marker:a,offset:n}}class ss{constructor(){this.decodeTransform=null,this.colorTransform=-1,this.width=0,this.height=0}parse(e){function t(){const y=e[n]<<8|e[n+1];return n+=2,y}function r(){const y=t();let I=n+y-2;const O=At(e,I,n);O&&O.invalid&&(I=O.offset);const D=e.subarray(n,I);return n+=D.length,D}function s(y){const I=Math.ceil(y.samplesPerLine/8/y.maxH),O=Math.ceil(y.scanLines/8/y.maxV);for(let D=0;D<y.components.length;D++){C=y.components[D];const z=Math.ceil(Math.ceil(y.samplesPerLine/8)*C.h/y.maxH),ae=Math.ceil(Math.ceil(y.scanLines/8)*C.v/y.maxV),fe=I*C.h,A=64*(O*C.v)*(fe+1);C.blockData=new Int16Array(A),C.blocksPerLine=z,C.blocksPerColumn=ae}y.mcusPerLine=I,y.mcusPerColumn=O}var n=0;let o=null,a=null,l,c;const u=[],h=[],f=[];let d=t();if(d!==65496)throw new Ee("SOI not found");for(d=t();d!==65497;){var m,v,p;switch(d){case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var b=r();d===65504&&b[0]===74&&b[1]===70&&b[2]===73&&b[3]===70&&b[4]===0&&(o={version:{major:b[5],minor:b[6]},densityUnits:b[7],xDensity:b[8]<<8|b[9],yDensity:b[10]<<8|b[11],thumbWidth:b[12],thumbHeight:b[13],thumbData:b.subarray(14,14+3*b[12]*b[13])}),d===65518&&b[0]===65&&b[1]===100&&b[2]===111&&b[3]===98&&b[4]===101&&(a={version:b[5]<<8|b[6],flags0:b[7]<<8|b[8],flags1:b[9]<<8|b[10],transformCode:b[11]});break;case 65499:for(var g=t(),E=g+n-2,T;n<E;){const y=e[n++],I=new Uint16Array(64);if(y>>4===0)for(v=0;v<64;v++)T=We[v],I[T]=e[n++];else if(y>>4===1)for(v=0;v<64;v++)T=We[v],I[T]=t();else throw new Ee("DQT - invalid table spec");u[y&15]=I}break;case 65472:case 65473:case 65474:if(l)throw new Ee("Only single frame JPEGs supported");t(),l={},l.extended=d===65473,l.progressive=d===65474,l.precision=e[n++],l.scanLines=t(),l.samplesPerLine=t(),l.components=[],l.componentIds={};var _=e[n++],x,L=0,F=0;for(m=0;m<_;m++){x=e[n];const y=e[n+1]>>4,I=e[n+1]&15;L<y&&(L=y),F<I&&(F=I);const O=e[n+2];p=l.components.push({h:y,v:I,quantizationId:O,quantizationTable:null}),l.componentIds[x]=p-1,n+=3}l.maxH=L,l.maxV=F,s(l);break;case 65476:var V=t();for(m=2;m<V;){const y=e[n++],I=new Uint8Array(16);let O=0;for(v=0;v<16;v++,n++)O+=I[v]=e[n];const D=new Uint8Array(O);for(v=0;v<O;v++,n++)D[v]=e[n];m+=17+O,(y>>4===0?f:h)[y&15]=es(I,D)}break;case 65501:t(),c=t();break;case 65498:t();var N=e[n++],k=[],C;for(m=0;m<N;m++){const y=l.componentIds[e[n++]];C=l.components[y];const I=e[n++];C.huffmanTableDC=f[I>>4],C.huffmanTableAC=h[I&15],k.push(C)}var B=e[n++],R=e[n++],w=e[n++],U=ts(e,n,l,k,c,B,R,w>>4,w&15);n+=U;break;case 65535:e[n]!==255&&n--;break;default:if(e[n-3]===255&&e[n-2]>=192&&e[n-2]<=254){n-=3;break}throw new Ee("unknown marker "+d.toString(16))}d=t()}for(this.width=l.samplesPerLine,this.height=l.scanLines,this.jfif=o,this.adobe=a,this.components=[],m=0;m<l.components.length;m++){C=l.components[m];const y=u[C.quantizationId];y&&(C.quantizationTable=y),this.components.push({output:is(l,C),scaleX:C.h/l.maxH,scaleY:C.v/l.maxV,blocksPerLine:C.blocksPerLine,blocksPerColumn:C.blocksPerColumn})}this.numComponents=this.components.length}getData(e){const t=e.data,r=this.components,s=new Uint8Array((r[0].blocksPerLine<<3)*r[0].blocksPerColumn*8);[r[0],r[2]]=[r[2],r[0]];for(let l=0,c=r.length;l<c;l++){const u=r[l],h=u.blocksPerLine,f=u.blocksPerColumn,d=h<<3;var n,o,a=0;for(let v=0;v<f;v++){const p=v<<3;for(let b=0;b<h;b++){const g=pt(u,v,b);let E=0,T=b<<3;for(n=0;n<8;n++){var a=(p+n)*d;for(o=0;o<8;o++)s[a+T+o]=u.output[g+E++]}}}let m=l;for(let v=0;v<this.height;v++)for(let p=0;p<this.width;p++)t[m]=s[v*d+p],m+=c}return t}}const ns=827345986,Yt=0;class Rt{content=0;alphaBits=0;width=0;height=0;type=0;hasMipmaps=!1;mipmapOffsets=new Uint32Array(16);mipmapSizes=new Uint32Array(16);uint8array=null;jpgHeader=null;pallete=null;load(e){const t=wr(e),r=new Int32Array(t.buffer,0,40);if(r[0]!==ns)throw new Error("WrongMagicNumber");this.content=r[1],this.alphaBits=r[2],this.width=r[3],this.height=r[4],this.type=r[5],this.hasMipmaps=r[6]!==0;for(let s=0;s<16;s++)this.mipmapOffsets[s]=r[7+s],this.mipmapSizes[s]=r[23+s];this.uint8array=t,this.content===Yt?this.jpgHeader=t.subarray(160,160+r[39]):this.pallete=t.subarray(156,1180)}getMipmap(e){const t=this.uint8array,r=this.mipmapOffsets[e],s=this.mipmapSizes[e];let n;if(this.content===Yt){const o=this.jpgHeader,a=new Uint8Array(o.length+s),l=new ss;a.set(o),a.set(t.subarray(r,r+s),o.length),l.parse(a),n=new ImageData(l.width,l.height),l.getData(n)}else{const o=this.pallete,a=Math.max(this.width/(1<<e),1),l=Math.max(this.height/(1<<e),1),c=a*l;let u=this.alphaBits,h,f=0;n=new ImageData(a,l),u>0&&(u>8&&(u=8),h=new Xi(t.buffer,r+c,Math.ceil(c*u/8)),f=Qi(u,8));const d=n.data;for(let m=0;m<c;m++){const v=m*4,p=t[r+m]*4;d[v]=o[p+2],d[v+1]=o[p+1],d[v+2]=o[p],u>0?d[v+3]=h.readBits(u)*f:d[v+3]=255}}return n}mipmaps(){let e=0;for(const t of this.mipmapSizes)t>0&&(e+=1);return e}fakeMipmaps(){const e=this.mipmapOffsets;let t=0;for(let r=0;r<16;r++){const s=e[r];if(s>0){for(let n=r+1;n<16;n++)if(s===e[n]){t+=1;break}}}return t}}async function Wt(i,e){if(e==="image")return new Promise(t=>{const r=new Image;r.onload=()=>{t({ok:!0,data:r})},r.onerror=s=>{t({ok:!1,error:"Image Error",data:s})},r.src=i});{let t;try{t=await fetch(i)}catch(r){return{ok:!1,error:"Network Error",data:r}}if(!t.ok)return{ok:!1,error:"Http Error",data:t};try{let r=null;return e==="text"?r=await t.text():e==="arrayBuffer"||e==="bytes"?r=await t.arrayBuffer():e==="blob"&&(r=await t.blob()),e==="bytes"&&(r=new Uint8Array(r)),{ok:!0,data:r}}catch(r){return{ok:!1,error:"Data Error",data:r}}}}class os{gl;buffer;size=0;arrayBuffer=null;byteView=null;floatView=null;constructor(e,t=4){this.gl=e,this.buffer=e.createBuffer(),this.reserve(t)}reserve(e){if(this.size<e){const t=this.gl;this.size=Math.ceil(e/4)*4,t.bindBuffer(t.ARRAY_BUFFER,this.buffer),t.bufferData(t.ARRAY_BUFFER,this.size,t.DYNAMIC_DRAW),this.arrayBuffer=new ArrayBuffer(this.size),this.byteView=new Uint8Array(this.arrayBuffer),this.floatView=new Float32Array(this.arrayBuffer)}}bindAndUpdate(e=this.size){const t=this.gl,r=this.byteView;t.bindBuffer(t.ARRAY_BUFFER,this.buffer),t.bufferSubData(t.ARRAY_BUFFER,0,r.subarray(0,e))}}class as{gl;texture;width=0;height=0;arrayBuffer=new ArrayBuffer(0);byteView=null;floatView=null;constructor(e,t=1,r=1){this.gl=e,this.texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.texture),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),this.reserve(t,r)}reserve(e,t){if(this.width<e||this.height<t){const r=this.gl;this.width=Math.max(this.width,e),this.height=Math.max(this.height,t),r.bindTexture(r.TEXTURE_2D,this.texture),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,this.width,this.height,0,r.RGBA,r.FLOAT,null),this.arrayBuffer=new ArrayBuffer(this.width*this.height*16),this.byteView=new Uint8Array(this.arrayBuffer),this.floatView=new Float32Array(this.arrayBuffer)}}bindAndUpdate(e=this.width,t=this.height){const r=this.gl;r.bindTexture(r.TEXTURE_2D,this.texture),r.texSubImage2D(r.TEXTURE_2D,0,0,0,e,t,r.RGBA,r.FLOAT,this.byteView)}}class Pr{gl;texture;format;width=0;height=0;constructor(e,t=4,r=1,s=1){this.gl=e,this.texture=e.createTexture(),this.format=t===3?e.RGB:e.RGBA,e.bindTexture(e.TEXTURE_2D,this.texture),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),this.reserve(r,s)}reserve(e,t){if(this.width<e||this.height<t){const r=this.gl;this.width=Math.max(this.width,e),this.height=Math.max(this.height,t),r.bindTexture(r.TEXTURE_2D,this.texture),r.texImage2D(r.TEXTURE_2D,0,this.format,this.width,this.height,0,this.format,r.FLOAT,null)}}bindAndUpdate(e,t=this.width,r=this.height){const s=this.gl;s.bindTexture(s.TEXTURE_2D,this.texture),s.texSubImage2D(s.TEXTURE_2D,0,0,0,t,r,this.format,s.FLOAT,e)}bind(e){const t=this.gl;t.activeTexture(t.TEXTURE0+e),t.bindTexture(t.TEXTURE_2D,this.texture)}}class ls{webgl;program;uniforms={};attribs={};attribsCount=0;constructor(e,t){this.webgl=e,this.program=t;const r=e.gl;for(let s=0,n=r.getProgramParameter(t,r.ACTIVE_UNIFORMS);s<n;s++){const o=r.getActiveUniform(t,s);if(o)if(o.size===1)this.uniforms[o.name]=r.getUniformLocation(t,o.name);else{const a=o.name.substr(0,o.name.length-3);for(let l=0;l<o.size;l++){const c=a+"["+l+"]";this.uniforms[c]=r.getUniformLocation(t,c)}}}for(let s=0,n=r.getProgramParameter(t,r.ACTIVE_ATTRIBUTES);s<n;s++){const o=r.getActiveAttrib(t,s);if(o)if(this.attribsCount+=o.size,o.size===1)this.attribs[o.name]=r.getAttribLocation(t,o.name);else{const a=o.name.substr(0,o.name.length-3);for(let l=0;l<o.size;l++){const c=a+"["+l+"]";this.attribs[c]=r.getAttribLocation(t,c)}}}}use(){this.webgl.useShader(this)}}class cs{gl;currentShader=null;emptyTexture;extensions={};constructor(e,t={alpha:!1}){let r=e.getContext("webgl",t);if(r||(r=e.getContext("experimental-webgl",t)),!r)throw new Error("WebGL: Failed to create a WebGL context!");const s=new Uint8ClampedArray(16).fill(255),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,2,2,0,r.RGBA,r.UNSIGNED_BYTE,s),this.gl=r,this.emptyTexture=n}ensureExtension(e){const t=this.gl.getExtension(e);return t?(this.extensions[e]=t,!0):!1}createShader(e,t){const r=this.gl,s=r.createShader(r.VERTEX_SHADER);r.shaderSource(s,e),r.compileShader(s);const n=r.createShader(r.FRAGMENT_SHADER);r.shaderSource(n,t),r.compileShader(n);const o=r.createProgram();if(r.attachShader(o,s),r.attachShader(o,n),r.linkProgram(o),!r.getProgramParameter(o,r.LINK_STATUS)){let a="Shader failed to link:";const l=r.getShaderInfoLog(s);l&&l.length&&(a+=` Vertex shader: ${l}`);const c=r.getShaderInfoLog(n);throw c&&c.length&&(a+=` Fragment shader: ${c}`),new Error(a)}return new ls(this,o)}enableVertexAttribs(e,t){const r=this.gl;for(let s=e;s<t;s++)r.enableVertexAttribArray(s)}disableVertexAttribs(e,t){const r=this.gl;for(let s=e;s<t;s++)r.disableVertexAttribArray(s)}useShader(e){if(e&&e!==this.currentShader){let t=0;const r=e.attribsCount;this.currentShader&&(t=this.currentShader.attribsCount),this.gl.useProgram(e.program),r>t?this.enableVertexAttribs(t,r):r<t&&this.disableVertexAttribs(r,t),this.currentShader=e}}bindTexture(e,t){const r=this.gl;r.activeTexture(r.TEXTURE0+t),e?r.bindTexture(r.TEXTURE_2D,e.webglResource):r.bindTexture(r.TEXTURE_2D,this.emptyTexture)}bindTextureAndWrap(e,t,r,s){const n=this.gl;n.activeTexture(n.TEXTURE0+t),e?n.bindTexture(n.TEXTURE_2D,e.webglResource):n.bindTexture(n.TEXTURE_2D,this.emptyTexture),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,r),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,s)}setTextureMode(e,t,r,s){const n=this.gl;n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,e),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,t),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,r),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,s)}createClientBuffer(e=4){return new os(this.gl,e)}createDataTexture(e=4,t=1,r=1){return new Pr(this.gl,e,t,r)}createClientDataTexture(e=1,t=1){return new as(this.gl,e,t)}}const ze=M(),hs=M(),us=M(),fs=$(),ds=Ne($(),Ft,Math.PI/2);let ms=class{isPerspective=!0;fov=0;aspect=0;isOrtho=!1;leftClipPlane=0;rightClipPlane=0;bottomClipPlane=0;topClipPlane=0;nearClipPlane=0;farClipPlane=0;location=M();rotation=$();inverseRotation=$();viewMatrix=Ce();projectionMatrix=Ce();viewProjectionMatrix=Ce();inverseViewMatrix=Ce();inverseViewProjectionMatrix=Ce();directionX=M();directionY=M();directionZ=M();vectors=[q(-1,-1,0),q(-1,1,0),q(1,1,0),q(1,-1,0),q(1,0,0),q(0,1,0),q(0,0,1)];billboardedVectors=[M(),M(),M(),M(),M(),M(),M()];planes=[xe(),xe(),xe(),xe(),xe(),xe()];perspective(e,t,r,s){this.isPerspective=!0,this.isOrtho=!1,this.fov=e,this.aspect=t,this.nearClipPlane=r,this.farClipPlane=s,this.update()}ortho(e,t,r,s,n,o){this.isPerspective=!1,this.isOrtho=!0,this.leftClipPlane=e,this.rightClipPlane=t,this.bottomClipPlane=r,this.topClipPlane=s,this.nearClipPlane=n,this.farClipPlane=o,this.update()}setLocation(e){oe(this.location,e),this.update()}move(e){Te(this.location,this.location,e),this.update()}setRotation(e){Be(this.rotation,e),this.update()}rotate(e){re(this.rotation,this.rotation,e),this.update()}face(e,t){re(this.rotation,ds,Lr(fs,e,this.location,t)),this.update()}moveToAndFace(e,t,r){oe(this.location,e),this.face(t,r)}reset(){_e(this.location,0,0,0),It(this.rotation),this.update()}update(){const e=this.location,t=this.rotation,r=this.inverseRotation,s=this.viewMatrix,n=this.projectionMatrix,o=this.viewProjectionMatrix,a=this.vectors,l=this.billboardedVectors;this.isPerspective?xi(n,this.fov,this.aspect,this.nearClipPlane,this.farClipPlane):_i(n,this.leftClipPlane,this.rightClipPlane,this.bottomClipPlane,this.topClipPlane,this.nearClipPlane,this.farClipPlane),gi(s,t),pi(s,s,Si(ze,e)),Lt(o,n,s),zt(this.inverseViewMatrix,s),zt(this.inverseViewProjectionMatrix,o),ji(this.planes,o),Ar(r,t),he(this.directionX,Ft,r),he(this.directionY,Cr,r),he(this.directionZ,Ze,r);for(let c=0;c<7;c++)he(l[c],a[c],r)}cameraToWorld(e,t){return we(e,t,this.inverseViewMatrix)}worldToCamera(e,t){return we(e,t,this.viewMatrix)}worldToScreen(e,t,r){return we(ze,t,this.viewProjectionMatrix),e[0]=Math.round((ze[0]+1)/2*r[2]),e[1]=Math.round((ze[1]+1)/2*r[3]),e}screenToWorldRay(e,t,r){const s=ze,n=hs,o=us,a=t[0],l=t[1],c=this.inverseViewProjectionMatrix;return Xt(s,_e(o,a,l,0),c,r),Xt(n,_e(o,a,l,1),c,r),e.set(s,0),e.set(n,3),e}};class vs{left;right;bottom;top;plane=-1;instances=[];visible=!1;constructor(e,t,r,s){this.left=e,this.right=t,this.bottom=r,this.top=s}add(e){this.instances.push(e)}remove(e){const t=this.instances.indexOf(e);this.instances.splice(t,1)}clear(){this.instances.length=0}isVisible(e){return this.plane=ki(e.planes,this.left,this.right,this.bottom,this.top,this.plane),this.plane===-1}}class ps{x;y;width;depth;cellWidth;cellDepth;columns;rows;cells=[];constructor(e,t,r,s,n,o){const a=r/n,l=s/o;this.x=e,this.y=t,this.width=r,this.depth=s,this.cellWidth=n,this.cellDepth=o,this.columns=a,this.rows=l;for(let c=0;c<l;c++)for(let u=0;u<a;u++){const h=e+u*n,f=h+n,d=t+c*o,m=d+o;this.cells[c*a+u]=new vs(h,f,d,m)}}add(e){const t=this.cells,r=this.columns,s=e.left,n=e.right+1,o=e.bottom,a=e.top+1;if(s!==-1)for(let l=o;l<a;l++)for(let c=s;c<n;c++)t[l*r+c].add(e)}remove(e){const t=this.cells,r=this.columns,s=e.left,n=e.right+1,o=e.bottom,a=e.top+1;if(s!==-1){e.left=-1;for(let l=o;l<a;l++)for(let c=s;c<n;c++)t[l*r+c].remove(e)}}moved(e){const t=this.cellWidth,r=this.cellDepth,s=e.model.bounds,n=e.worldLocation[0]+s.x-this.x,o=e.worldLocation[1]+s.y-this.y,a=s.r,l=e.worldScale;let c=Math.floor((n-a*l[0])/t),u=Math.floor((n+a*l[0])/t),h=Math.floor((o-a*l[1])/r),f=Math.floor((o+a*l[1])/r);u<0||c>this.columns-1||f<0||h>this.rows-1?this.remove(e):(c=Math.max(c,0),u=Math.min(u,this.columns-1),h=Math.max(h,0),f=Math.min(f,this.rows-1),(c!==e.left||u!==e.right||h!==e.bottom||f!==e.top)&&(this.remove(e),e.left=c,e.right=u,e.bottom=h,e.top=f,this.add(e)))}clear(){for(const e of this.cells)e.clear()}}class bs{objects=[];alive=0;add(e){this.objects[this.alive++]=e}update(e){const t=this.objects;for(let r=0;r<this.alive;r++){const s=t[r];s.update(e*s.emitter.instance.timeScale),s.health<=0&&(this.alive-=1,s.emitter.kill(s),r!==this.alive&&(t[r]=t[this.alive],r-=1))}}}class gs{viewer;camera=new ms;grid=new ps(-1e5,-1e5,2e5,2e5,2e5,2e5);visibleCells=0;visibleInstances=0;updatedParticles=0;audioEnabled=!1;audioContext=null;instances=[];emittedObjectUpdater=new bs;alpha=!1;color=M();viewport=xe();lightPosition=q(0,0,1e4);constructor(e){this.viewer=e;const t=e.canvas,r=t.width,s=t.height;this.viewport[2]=r,this.viewport[3]=s,this.camera.perspective(Math.PI/4,r/s,8,1e4)}async enableAudio(){return typeof AudioContext=="function"?(this.audioContext||(this.audioContext=new AudioContext),this.audioContext.state!=="suspended"&&await this.audioContext.resume(),this.audioEnabled=this.audioContext.state==="running",this.audioEnabled):!1}disableAudio(){this.audioContext&&this.audioContext.suspend(),this.audioEnabled=!1}addInstance(e){return e.scene!==this?(e.scene&&e.scene.removeInstance(e),e.scene=this,this.grid.moved(e),!0):!1}removeInstance(e){return e.scene===this?(this.grid.remove(e),e.scene=null,!0):!1}clear(){for(const e of this.grid.cells)for(const t of e.instances)t.scene=null;this.grid.clear()}detach(){return this.viewer?this.viewer.removeScene(this):!1}update(e){const t=this.camera;if(this.audioContext){const n=this.audioContext.listener,o=t.location,a=t.directionY,l=t.directionZ;n.positionX.value=-o[0],n.positionY.value=-o[1],n.positionZ.value=-o[2],n.forwardX.value=a[0],n.forwardY.value=a[1],n.forwardZ.value=a[2],n.upX.value=l[0],n.upY.value=l[1],n.upZ.value=l[2]}const r=this.viewer.frame,s=this.instances;this.visibleCells=0,this.visibleInstances=0;for(const n of this.grid.cells)if(n.isVisible(t)){this.visibleCells+=1;for(const o of n.instances)o.rendered&&o.updateFrame<r&&!o.parent&&(o.updateFrame=r,o.update(e))}s.length=this.visibleInstances,s.sort((n,o)=>n.depth-o.depth),this.emittedObjectUpdater.update(e),this.updatedParticles=this.emittedObjectUpdater.alive}renderInstance(e){this.instances[this.visibleInstances++]=e}startFrame(){const e=this.viewer.gl,t=this.viewport;if(e.viewport(t[0],t[1],t[2],t[3]),e.scissor(t[0],t[1],t[2],t[3]),!this.alpha){const r=this.color;e.depthMask(!0),e.clearColor(r[0],r[1],r[2],1),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT)}}renderOpaque(){const e=this.instances;for(let t=0,r=e.length;t<r;t++)e[t].renderOpaque()}renderTranslucent(){const e=this.instances;for(let t=e.length-1;t>=0;t--)e[t].renderTranslucent()}render(){this.startFrame(),this.renderOpaque(),this.renderTranslucent()}clearEmittedObjects(){for(const e of this.emittedObjectUpdater.objects)e.health=0}}class Nt{viewer;fetchUrl;blockers=[];constructor(e){this.viewer=e.viewer,this.fetchUrl=e.fetchUrl}detach(){return this.viewer.unload(this)}}class xs extends Nt{data=null;constructor(e,t){super(t),this.data=e}}class Fr extends Nt{pathSolver;constructor(e){super(e),this.pathSolver=e.pathSolver}}class Or extends Fr{webglResource=null;width=0;height=0}function _s(i){return i instanceof ImageData||i instanceof HTMLImageElement||i instanceof HTMLCanvasElement||i instanceof HTMLVideoElement}function Ts(i){return Ki(i)?"image/png":Yi(i)?"image/jpeg":Wi(i)?"image/gif":$i(i)?"image/webp":""}class $t extends Or{constructor(e,t){super(t);const r=this.viewer.gl;this.webglResource=r.createTexture(),r.bindTexture(r.TEXTURE_2D,this.webglResource),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,e),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.LINEAR),mt(e.width)&&mt(e.height)?(r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.LINEAR_MIPMAP_LINEAR),r.generateMipmap(r.TEXTURE_2D)):(r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.LINEAR),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),this.width=e.width,this.height=e.height}}var P=(i=>(i[i.None=0]="None",i[i.Diffuse=1]="Diffuse",i[i.NormalMap=2]="NormalMap",i[i.Occlusion=3]="Occlusion",i[i.Roughness=4]="Roughness",i[i.Metallic=5]="Metallic",i[i.TCFactor=6]="TCFactor",i[i.Emissive=7]="Emissive",i[i.TexCoords=8]="TexCoords",i[i.Normals=9]="Normals",i[i.Tangents=10]="Tangents",i))(P||{});class Jn extends fi.EventEmitter{canvas;gl;webgl;resources=[];resourceMap=new Map;promiseMap=new Map;handlers=new Set;scenes=[];frame=0;visibleCells=0;visibleInstances=0;updatedParticles=0;audioEnabled=!1;buffer;sharedCache=new Map;debugRenderMode=0;directLoadId=0;constructor(e,t){super();const r=new cs(e,t),s=r.gl;this.canvas=e,this.gl=s,this.webgl=r,this.buffer=r.createClientBuffer(),s.depthFunc(s.LEQUAL),s.enable(s.DEPTH_TEST),s.enable(s.SCISSOR_TEST)}enableAudio(){return typeof AudioContext=="function"?(this.audioEnabled=!0,!0):!1}addHandler(e,...t){if(e){const r=this.handlers;if(!r.has(e)){if(!e.isValidSource)return this.emit("error",{viewer:this,error:"Handler missing the isValidSource function",handler:e}),!1;if(e.load)try{e.load(this,...t)}catch(s){return this.emit("error",{viewer:this,error:"Handler failed to load",handler:e,reason:s}),!1}return r.add(e),!0}}return!1}addScene(){const e=new gs(this);return this.scenes.push(e),e}removeScene(e){const t=this.scenes,r=t.indexOf(e);return r!==-1?(t.splice(r,1),!0):!1}clear(){this.scenes.length=0}async load(e,t,r){let s,n="",o;if(t)try{s=t(e,r)}catch(a){this.emit("error",{viewer:this,error:"Path solver failed",src:e,reason:a,pathSolver:t,solverParams:r});return}else s=e;if(s){if(s instanceof Promise&&(s=await s),s instanceof Nt)return s;if(typeof s=="string"&&!this.detectFormat(s)){if(n=s,o=this.promiseMap.get(n),o)return o;const a=this.resourceMap.get(n);if(a)return a;o=Wt(n,"arrayBuffer").then(l=>{if(l.ok)return l.data;this.emit("error",{viewer:this,error:`Failed to fetch a resource: ${l.error}`,fetchUrl:n,reason:l.data})})}else n=`__DIRECT_LOAD_${this.directLoadId++}`,o=Promise.resolve(s);return o=o.then(async a=>{if(a){if(a instanceof ArrayBuffer&&(a=new Uint8Array(a)),_s(a))return new $t(a,{viewer:this,fetchUrl:n,pathSolver:t});if(a instanceof Uint8Array){const c=Ts(a);if(c.length)return new $t(await zi(new Blob([a.buffer],{type:c})),{viewer:this,fetchUrl:n,pathSolver:t})}const l=this.detectFormat(a);if(l)try{const c=new l.resource(a,{viewer:this,fetchUrl:n,pathSolver:t});return await Promise.all(c.blockers),c.blockers.length=0,c}catch(c){this.emit("error",{viewer:this,error:"Failed to create a resource",fetchUrl:n,src:e,reason:c})}else this.emit("error",{viewer:this,error:"Source has no matching handler",fetchUrl:n,src:e})}}).then(a=>(this.promiseMap.delete(n),a&&(this.resourceMap.set(n,a),this.resources.push(a),this.emit("load",{viewer:this,fetchUrl:n,resource:a})),this.emit("loadend",{viewer:this,fetchUrl:n,resource:a}),this.checkLoadingStatus(),a)),this.promiseMap.set(n,o),this.emit("loadstart",{viewer:this,fetchUrl:n,promise:o}),o}}detectFormat(e){for(const t of this.handlers)if(t.isValidSource(e))return t}has(e){return this.resourceMap.has(e)}get(e){return this.resourceMap.get(e)}async loadGeneric(e,t,r){const s=this.promiseMap.get(e);if(s)return s;const n=this.resourceMap.get(e);if(n)return n;const o=Wt(e,t).then(async a=>{this.promiseMap.delete(e);let l;if(a.ok){let c=a.data;r&&(c=await r(c)),l=new xs(c,{viewer:this,fetchUrl:e}),this.resourceMap.set(e,l),this.resources.push(l),this.emit("load",{viewer:this,fetchUrl:e,resource:l})}else this.emit("error",{viewer:this,error:"Failed to fetch a generic resource",fetchUrl:e});return this.emit("loadend",{viewer:this,fetchUrl:e,resource:l}),this.checkLoadingStatus(),l});return this.promiseMap.set(e,o),this.emit("loadstart",{viewer:this,fetchUrl:e}),o}unload(e){const t=e.fetchUrl;t!==""&&this.resourceMap.delete(t);const r=this.resources,s=r.indexOf(e);return s!==-1?(r.splice(s,1),!0):!1}promise(){const e=Promise.resolve(void 0),t=`${performance.now()}`;return this.promiseMap.set(t,e),()=>{this.promiseMap.delete(t),this.checkLoadingStatus()}}checkLoadingStatus(){this.promiseMap.size===0&&setTimeout(()=>this.emit("idle"),0)}whenAllLoaded(e){const t=new Promise(r=>{this.promiseMap.size===0?r(this):this.once("idle",()=>r(this))});if(e)t.then(()=>e(this));else return t}toBlob(e){const t=new Promise(r=>this.canvas.toBlob(s=>r(s)));if(e)t.then(r=>e(r));else return t}updateAndRender(e=1e3/60){this.update(e),this.startFrame(),this.render()}update(e=1e3/60){e*=.001,this.frame+=1,this.visibleCells=0,this.visibleInstances=0,this.updatedParticles=0;for(const t of this.scenes)t.update(e),this.visibleCells+=t.visibleCells,this.visibleInstances+=t.visibleInstances,this.updatedParticles+=t.updatedParticles}startFrame(){const e=this.gl;e.depthMask(!0),e.clearColor(0,0,0,1),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT)}render(){for(const e of this.scenes)e.render()}clearEmittedObjects(){for(const e of this.scenes)e.clearEmittedObjects()}}const Es=M(),ws=$(),Ss=M();class ys{pivot=M();localLocation=M();localRotation=$();localScale=q(1,1,1);worldLocation=M();worldRotation=$();worldScale=q(1,1,1);inverseWorldLocation=M();inverseWorldRotation=$();inverseWorldScale=q(1,1,1);localMatrix=Ce();worldMatrix=Ce();dontInheritTranslation=!1;dontInheritRotation=!1;dontInheritScaling=!0;parent=null;children=[];setPivot(e){return oe(this.pivot,e),this.recalculateTransformation(),this}setLocation(e){return oe(this.localLocation,e),this.recalculateTransformation(),this}setRotation(e){return Be(this.localRotation,e),this.recalculateTransformation(),this}setScale(e){return oe(this.localScale,e),this.recalculateTransformation(),this}setUniformScale(e){return _e(this.localScale,e,e,e),this.recalculateTransformation(),this}setTransformation(e,t,r){const s=this.localLocation,n=this.localRotation,o=this.localScale;return s[0]=e[0],s[1]=e[1],s[2]=e[2],n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],o[0]=r[0],o[1]=r[1],o[2]=r[2],this.recalculateTransformation(),this}resetTransformation(){return oe(this.pivot,Ue),oe(this.localLocation,Ue),Be(this.localRotation,Dt),oe(this.localScale,Ot),this.recalculateTransformation(),this}movePivot(e){return Te(this.pivot,this.pivot,e),this.recalculateTransformation(),this}move(e){return Te(this.localLocation,this.localLocation,e),this.recalculateTransformation(),this}rotate(e){return re(this.localRotation,this.localRotation,e),this.recalculateTransformation(),this}rotateLocal(e){return re(this.localRotation,e,this.localRotation),this.recalculateTransformation(),this}scale(e){return $e(this.localScale,this.localScale,e),this.recalculateTransformation(),this}uniformScale(e){return vt(this.localScale,this.localScale,e),this.recalculateTransformation(),this}face(e,t){return Ar(this.localRotation,Lr(this.localRotation,this.localLocation,e,t)),this.recalculateTransformation(),this}setParent(e){if(this.parent){const t=this.parent.children,r=t.indexOf(this);r!==-1&&t.splice(r,1)}return this.parent=e||null,e&&e.children.push(this),this.recalculateTransformation(),this}recalculateTransformation(){const e=this.parent,t=this.localMatrix,r=this.localLocation,s=this.localRotation,n=this.localScale,o=this.worldMatrix,a=this.worldLocation,l=this.worldRotation,c=this.worldScale,u=this.inverseWorldLocation,h=this.inverseWorldRotation,f=this.inverseWorldScale;if(e){const d=Es,m=e.pivot;let v,p;if(d[0]=r[0]+m[0],d[1]=r[1]+m[1],d[2]=r[2]+m[2],this.dontInheritRotation?(v=ws,re(v,s,e.inverseWorldRotation)):v=s,this.dontInheritScaling){p=Ss;const b=e.inverseWorldScale;p[0]=b[0]*n[0],p[1]=b[1]*n[1],p[2]=b[2]*n[2],c[0]=n[0],c[1]=n[1],c[2]=n[2]}else{p=n;const b=e.worldScale;c[0]=b[0]*n[0],c[1]=b[1]*n[1],c[2]=b[2]*n[2]}qt(t,v,d,p),Lt(o,e.worldMatrix,t),re(l,e.worldRotation,v)}else qt(t,s,r,n),o[0]=t[0],o[1]=t[1],o[2]=t[2],o[3]=t[3],o[4]=t[4],o[5]=t[5],o[6]=t[6],o[7]=t[7],o[8]=t[8],o[9]=t[9],o[10]=t[10],o[11]=t[11],o[12]=t[12],o[13]=t[13],o[14]=t[14],o[15]=t[15],l[0]=s[0],l[1]=s[1],l[2]=s[2],l[3]=s[3],c[0]=n[0],c[1]=n[1],c[2]=n[2];h[0]=-l[0],h[1]=-l[1],h[2]=-l[2],h[3]=l[3],f[0]=1/c[0],f[1]=1/c[1],f[2]=1/c[2],a[0]=o[12],a[1]=o[13],a[2]=o[14],u[0]=-a[0],u[1]=-a[1],u[2]=-a[2];for(const d of this.children)d.recalculateTransformation()}update(e){for(const t of this.children)t.update(e)}}class Dr{x=0;y=0;z=0;r=0;fromExtents(e,t){const r=e[0],s=e[1],n=e[2],o=t[0]-r,a=t[1]-s,l=t[2]-n;this.x=r+o/2,this.y=s+a/2,this.z=n+l/2,this.r=Math.max(0,Math.max(o,a,l)/2)}}class As extends Fr{bounds=new Dr}class Rs extends ys{scene=null;left=-1;right=-1;bottom=-1;top=-1;plane=-1;depth=0;updateFrame=0;model;timeScale=1;rendered=!0;textureOverrides=new Map;constructor(e){super(),this.model=e}show(){this.rendered=!0}hide(){this.rendered=!1}shown(){return this.rendered}hidden(){return!this.rendered}detach(){return this.scene?this.scene.removeInstance(this):!1}overrideTexture(e,t){t?this.textureOverrides.set(e,t):this.textureOverrides.delete(e)}getBounds(){return this.model.bounds}clearEmittedObjects(){}setScene(e){return e.addInstance(this)}recalculateTransformation(){super.recalculateTransformation(),this.scene&&this.scene.grid.moved(this)}update(e){const t=this.scene;t&&this.rendered&&this.isVisible(t.camera)&&(t.renderInstance(this),this.updateAnimations(e*this.timeScale),super.update(e))}updateAnimations(e){}renderOpaque(){}renderTranslucent(){}isVisible(e){const[t,r,s]=this.worldLocation,[n,o,a]=this.worldScale,l=this.getBounds(),c=e.planes;let u=n;return o>u&&(u=o),a>u&&(u=a),this.plane=Gi(c,t+l.x,r+l.y,s+l.z,l.r*u,this.plane),this.plane===-1?(this.depth=Mr(c[4],t,r,s),!0):!1}}function Cs(i){return i instanceof ArrayBuffer&&(i=new Uint8Array(i)),i instanceof Uint8Array&&i[0]===66&&i[1]===76&&i[2]===80&&i[3]===49}class Ms extends Or{constructor(e,t){super(t);let r;e instanceof Rt?r=e:(r=new Rt,r.load(e));const n=this.viewer.gl,o=n.createTexture();n.bindTexture(n.TEXTURE_2D,o),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR);const a=mt(r.width)&&mt(r.height);a||(n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE));const l=r.mipmaps();if(l===1||r.fakeMipmaps()||!a){const c=r.getMipmap(0);n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,c)}else{n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR_MIPMAP_LINEAR);let c=r.width,u=r.height;for(let h=0;h<l;h++){const f=r.getMipmap(h);n.texImage2D(n.TEXTURE_2D,h,n.RGBA,c,u,0,n.RGBA,n.UNSIGNED_BYTE,f.data),c=Math.ceil(c/2),u=Math.ceil(u/2)}}this.width=r.width,this.height=r.height,this.webglResource=o}}const eo={isValidSource(i){return i instanceof Rt?!0:Cs(i)},resource:Ms},Pe=M(),xt=$(),Ls=M(),Ae=M(),le=$();class Nr{pivot;localLocation;localRotation;localScale;worldLocation;worldRotation;worldScale;inverseWorldLocation;inverseWorldRotation;inverseWorldScale;localMatrix;worldMatrix;dontInheritTranslation=!1;dontInheritRotation=!1;dontInheritScaling=!1;billboarded=!1;billboardedX=!1;billboardedY=!1;billboardedZ=!1;dirty=!0;wasDirty=!1;parent=null;children=[];object=null;constructor(e,t,r,s,n,o,a,l,c,u,h,f){this.pivot=e,this.localLocation=t,this.localRotation=r,this.localScale=s,this.worldLocation=n,this.worldRotation=o,this.worldScale=a,this.inverseWorldLocation=l,this.inverseWorldRotation=c,this.inverseWorldScale=u,this.localMatrix=h,this.worldMatrix=f,this.localRotation[3]=1,this.localScale.fill(1),this.localMatrix[0]=1,this.localMatrix[5]=1,this.localMatrix[10]=1,this.localMatrix[15]=1}recalculateTransformation(e){const t=e.scene,r=this.localMatrix,s=this.localLocation,n=this.localRotation,o=this.localScale,a=this.worldMatrix,l=this.worldLocation,c=this.worldRotation,u=this.worldScale,h=this.pivot,f=this.inverseWorldLocation,d=this.inverseWorldRotation,m=this.inverseWorldScale,v=this.parent;let p,b,g;if(this.dontInheritTranslation?(Te(Pe,v.inverseWorldLocation,l),p=Te(Pe,Pe,s)):p=s,this.dontInheritScaling?($e(Pe,v.inverseWorldScale,e.worldScale),g=$e(Pe,Pe,o)):g=o,this.billboarded)b=xt,Be(b,v.inverseWorldRotation),re(b,b,t.camera.inverseRotation),this.convertBasis(b),re(b,b,n);else{const{billboardedX:L,billboardedY:F,billboardedZ:V}=this;L||F||V?(L&&(g===o&&(g=Ls,oe(g,o)),g[2]*=-1),le[0]=-n[0],le[1]=-n[1],le[2]=-n[2],re(le,le,v.inverseWorldRotation),he(Ae,t.camera.billboardedVectors[6],le),L?Ne(le,Ft,Math.atan2(Ae[2],Ae[1])):F?Ne(le,Cr,Math.atan2(-Ae[2],Ae[0])):Ne(le,Ze,Math.atan2(Ae[1],Ae[0])),b=xt,re(b,n,le)):b=n}this.dontInheritRotation&&(re(le,v.inverseWorldRotation,e.worldRotation),b=re(xt,le,b)),bi(r,b,p,g,h),Lt(a,v.worldMatrix,r);const E=h[0],T=h[1],_=h[2];l[0]=a[0]*E+a[4]*T+a[8]*_+a[12],l[1]=a[1]*E+a[5]*T+a[9]*_+a[13],l[2]=a[2]*E+a[6]*T+a[10]*_+a[14],f[0]=-l[0],f[1]=-l[1],f[2]=-l[2],re(c,v.worldRotation,b),d[0]=-c[0],d[1]=-c[1],d[2]=-c[2],d[3]=c[3];const x=v.worldScale;u[0]=x[0]*g[0],u[1]=x[1]*g[1],u[2]=x[2]*g[2],m[0]=1/u[0],m[1]=1/u[1],m[2]=1/u[2]}convertBasis(e){}}const Is=65;function Ps(i,e=Nr){const t=new Float32Array(i*Is),r=[];let s=0;const n=i*3,o=i*4,a=i*16,l=t.subarray(s,s+n);s+=n;const c=t.subarray(s,s+n);s+=n;const u=t.subarray(s,s+o);s+=o;const h=t.subarray(s,s+n);s+=n;const f=t.subarray(s,s+n);s+=n;const d=t.subarray(s,s+o);s+=o;const m=t.subarray(s,s+n);s+=n;const v=t.subarray(s,s+n);s+=n;const p=t.subarray(s,s+o);s+=o;const b=t.subarray(s,s+n);s+=n;const g=t.subarray(s,s+a);s+=a;const E=t.subarray(s,s+a);for(let T=0;T<i;T++){const _=T*3,x=_+3,L=T*4,F=L+4,V=T*16,N=V+16;r[T]=new e(l.subarray(_,x),c.subarray(_,x),u.subarray(L,F),h.subarray(_,x),f.subarray(_,x),d.subarray(L,F),m.subarray(_,x),v.subarray(_,x),p.subarray(L,F),b.subarray(_,x),g.subarray(V,N),E.subarray(V,N))}return{data:t,nodes:r,pivots:l,localLocations:c,localRotations:u,localScales:h,worldLocations:f,worldRotations:d,worldScales:m,inverseWorldLocations:v,invereseWorldRotations:p,inverseWorldScales:b,localMatrices:g,worldMatrices:E}}const Vr=`
uniform sampler2D u_boneMap;
uniform float u_vectorSize;
uniform float u_rowSize;

mat4 fetchMatrix(float column, float row) {
  column *= u_vectorSize * 4.0;
  row *= u_rowSize;
  // Add in half a texel, to sample in the middle of the texel.
  // Otherwise, since the sample is directly on the boundary, floating point errors can cause the sample to get the wrong pixel.
  // This is most noticeable with NPOT textures, which the bone maps are.
  column += 0.5 * u_vectorSize;
  row += 0.5 * u_rowSize;

  return mat4(texture2D(u_boneMap, vec2(column, row)),
              texture2D(u_boneMap, vec2(column + u_vectorSize, row)),
              texture2D(u_boneMap, vec2(column + u_vectorSize * 2.0, row)),
              texture2D(u_boneMap, vec2(column + u_vectorSize * 3.0, row)));
}
`,Vt=`
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
`;let Ct;typeof OfflineAudioContext=="function"&&(Ct=new OfflineAudioContext(1,1,48e3));async function Fs(i){if(Ct)return Ct.decodeAudioData(i)}class Zt{map={};set(e,t){typeof t!="string"&&(t=t.toString()),this.map[e.toLowerCase()]=t}string(e){return this.map[e.toLowerCase()]}number(e){const t=this.string(e);return t?parseFloat(t):0}}class Os{map={};constructor(e){e&&this.load(e)}load(e){if(e.startsWith("ID;")){const t=new Zi;t.load(e);const r=t.rows,s=r[0],n=this.map;for(let o=1,a=r.length;o<a;o++){const l=r[o];if(l){const c=l[0];if(c&&c!=="_"){n[c]||(n[c]=new Zt);const u=n[c];for(let h=0,f=s.length;h<f;h++){let d=s[h];d===void 0&&(d=`column${h}`),u.map[d.toLowerCase()]=l[h]}}}}}else{const t=new ui;t.load(e);const r=t.sections,s=this.map;for(const[n,o]of r.entries()){s[n]||(s[n]=new Zt);const a=s[n];for(const[l,c]of o)a.map[l.toLowerCase()]=c}}}getRow(e){return this.map[e]}getProperty(e,t){return this.map[e].map[t]}setRow(e,t){this.map[e]=t}findRow(e,t){for(const r of Object.values(this.map))if(r.string(e)===t)return r}}class Ds{name;interval;nonLooping;rarity;bounds;constructor(e){this.name=e.name,this.interval=e.interval,this.nonLooping=e.nonLooping,this.rarity=e.rarity,this.bounds=new Dr;const t=e.extent;this.bounds.fromExtents(t.min,t.max)}}class Qt{sd;start;end;frames=[];values=[];inTans=[];outTans=[];constant=!1;constructor(e,t,r,s,n){this.sd=e,this.start=t,this.end=r;const o=e.interpolationType,a=s.frames,l=s.values,c=s.inTans,u=s.outTans,h=e.defval;n&&a[0]>r&&(this.frames[0]=a[0],this.values[0]=l[0]);for(let d=0,m=a.length;d<m;d++){const v=a[d];v>=t&&v<=r&&(this.frames.push(v),this.values.push(l[d]),o>1&&(this.inTans.push(c[d]),this.outTans.push(u[d])))}const f=this.frames.length;if(f===0)this.constant=!0,this.frames[0]=t,this.values[0]=h;else if(f===1)this.constant=!0;else{const d=this.values[0];this.constant=this.values.every(m=>d.every((v,p)=>v===m[p]))}}getValue(e,t){const s=this.frames.length;if(this.constant||t<this.start)return this.sd.copy(e,this.values[0]),-1;{let n=-1,o=-1;const a=s-1;if(t<this.frames[0]||t>=this.frames[a])n=a,o=0;else for(let f=1;f<s;f++)if(this.frames[f]>t){n=f-1,o=f;break}let l=this.frames[n];const c=this.frames[o];let u=c-l;u<0&&(u+=this.end-this.start,t<l&&(l=c));const h=u==0?0:(t-l)/u;return this.sd.interpolate(e,this.values,this.inTans,this.outTans,n,o,h),n}}}const Ns={KLAV:W.DontInterp,KATV:W.DontInterp,KPEV:W.DontInterp,KP2V:W.DontInterp,KRVS:W.DontInterp},j=new Float32Array(1),Vs=new Uint32Array(1),De=new Float32Array([1]),Xe=M(),Jt=$(),er=q(1,1,1),tr=De,ct=Xe,Bs={KMTF:j,KMTA:tr,KTAT:Xe,KTAR:Jt,KTAS:er,KGAO:tr,KGAC:ct,KLAS:j,KLAE:j,KLAC:ct,KLAI:j,KLBI:j,KLBC:ct,KLAV:De,KATV:De,KPEE:j,KPEG:j,KPLN:j,KPLT:j,KPEL:j,KPES:j,KPEV:De,KP2S:j,KP2R:j,KP2L:j,KP2G:j,KP2E:j,KP2N:j,KP2W:j,KP2V:De,KRHA:j,KRHB:j,KRAL:new Float32Array([0]),KRCO:ct,KRTX:j,KRVS:De,KCTR:Xe,KTTR:Xe,KCRL:Vs,KGTR:Xe,KGRT:Jt,KGSC:er};class Bt{defval;model;name;globalSequence=null;sequences=[];interpolationType;constructor(e,t){const r=e.globalSequences,s=t.globalSequenceId,n=Ns[t.name];if(this.model=e,this.name=t.name,this.defval=Bs[t.name],this.interpolationType=n!==void 0?n:t.interpolationType,s!==-1&&r)this.globalSequence=new Qt(this,0,r[s],t,!0);else for(const o of e.sequences){const a=o.interval;this.sequences.push(new Qt(this,a[0],a[1],t,!1))}}getValue(e,t,r,s){return this.globalSequence?this.globalSequence.getValue(e,s%this.globalSequence.end):this.sequences[t].getValue(e,r)}isVariant(e){return this.globalSequence?!this.globalSequence.constant:!this.sequences[e].constant}}class Us extends Bt{copy(e,t){e[0]=t[0]}interpolate(e,t,r,s,n,o,a){const l=this.interpolationType,c=t[n][0];l===W.DontInterp?e[0]=c:l===W.Linear?e[0]=ti(c,t[o][0],a):l===W.Hermite?e[0]=ri(c,s[n][0],r[o][0],t[o][0],a):l===W.Bezier&&(e[0]=ii(c,s[n][0],r[o][0],t[o][0],a))}}class Gs extends Bt{copy(e,t){oe(e,t)}interpolate(e,t,r,s,n,o,a){const l=this.interpolationType;l===W.DontInterp?oe(e,t[n]):l===W.Linear?Ai(e,t[n],t[o],a):l===W.Hermite?Ri(e,t[n],s[n],r[o],t[o],a):l===W.Bezier&&Ci(e,t[n],s[n],r[o],t[o],a)}}class ks extends Bt{copy(e,t){Be(e,t)}interpolate(e,t,r,s,n,o,a){const l=this.interpolationType;l===W.DontInterp?Be(e,t[n]):l===W.Linear?dt(e,t[n],t[o],a):(l===W.Hermite||l===W.Bezier)&&Ui(e,t[n],s[n],r[o],t[o],a)}}function Hs(i,e){return e instanceof oi||e instanceof ai?new Us(i,e):e instanceof li?new Gs(i,e):new ks(i,e)}class Je{model;animations=new Map;variants={};constructor(e,t){this.model=e;for(const r of t.animations)this.animations.set(r.name,Hs(e,r))}getScalarValue(e,t,r,s,n,o){if(r!==-1){const a=this.animations.get(t);if(a)return a.getValue(e,r,s,n)}return e[0]=o,-1}getVectorValue(e,t,r,s,n,o){if(r!==-1){const a=this.animations.get(t);if(a)return a.getValue(e,r,s,n)}return e[0]=o[0],e[1]=o[1],e[2]=o[2],-1}getQuatValue(e,t,r,s,n,o){if(r!==-1){const a=this.animations.get(t);if(a)return a.getValue(e,r,s,n)}return e[0]=o[0],e[1]=o[1],e[2]=o[2],e[3]=o[3],-1}addVariants(e,t){const r=this.animations.get(e),s=this.model.sequences.length,n=new Uint8Array(s);if(r)for(let o=0;o<s;o++)r.isVariant(o)&&(n[o]=1);this.variants[t]=n}addVariantIntersection(e,t){const r=this.model.sequences.length,s=new Uint8Array(r);for(let n=0;n<r;n++)for(const o of e)this.variants[o][n]&&(s[n]=1);this.variants[t]=s}}class js extends Je{constructor(e,t){super(e,t),this.addVariants("KTAT","translation"),this.addVariants("KTAR","rotation"),this.addVariants("KTAS","scale")}getTranslation(e,t,r,s){return this.getVectorValue(e,"KTAT",t,r,s,Ue)}getRotation(e,t,r,s){return this.getQuatValue(e,"KTAR",t,r,s,Dt)}getScale(e,t,r,s){return this.getVectorValue(e,"KTAS",t,r,s,Ot)}}function zs(i,e){return i===pe.Blend?[e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA]:i===pe.Additive?[e.SRC_ALPHA,e.ONE]:i===pe.AddAlpha?[e.SRC_ALPHA,e.ONE]:i===pe.Modulate?[e.ZERO,e.SRC_COLOR]:i===pe.Modulate2x?[e.DST_COLOR,e.SRC_COLOR]:[0,0]}function Br(i,e){return i===je.Blend?[e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA]:i===je.Additive?[e.SRC_ALPHA,e.ONE]:i===je.Modulate?[e.ZERO,e.SRC_COLOR]:i===je.Modulate2x?[e.DST_COLOR,e.SRC_COLOR]:i===je.AlphaKey?[e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA]:[0,0]}class qs extends Je{index;priorityPlane;filterMode;textureId=0;coordId;alpha;unshaded;sphereEnvironmentMap;twoSided;unfogged;noDepthTest;noDepthSet;depthMaskValue;blendSrc=0;blendDst=0;blended=!1;textureAnimation=null;constructor(e,t,r,s){super(e,t);let n=t.filterMode;const o=t.textureAnimationId,a=e.viewer.gl;this.index=r,this.priorityPlane=s,n>pe.Modulate2x&&(n=pe.Blend),this.filterMode=n,t.textureId!==-1&&(this.textureId=t.textureId),this.coordId=t.coordId,this.alpha=t.alpha;const l=t.flags;if(this.unshaded=l&Me.Unshaded,this.sphereEnvironmentMap=l&Me.SphereEnvMap,this.twoSided=l&Me.TwoSided,this.unfogged=l&Me.Unfogged,this.noDepthTest=l&Me.NoDepthTest,this.noDepthSet=l&Me.NoDepthSet,this.depthMaskValue=n===pe.None||n===pe.Transparent,n>pe.Transparent&&(this.blended=!0,[this.blendSrc,this.blendDst]=zs(n,a)),o!==-1){const c=e.textureAnimations[o];c&&(this.textureAnimation=c)}this.addVariants("KMTA","alpha"),this.addVariants("KMTF","textureId")}bind(e){const t=this.model.viewer.gl;t.uniform1f(e.uniforms.u_filterMode,this.filterMode),this.blended?(t.enable(t.BLEND),t.blendFunc(this.blendSrc,this.blendDst)):t.disable(t.BLEND),this.twoSided?t.disable(t.CULL_FACE):t.enable(t.CULL_FACE),this.noDepthTest?t.disable(t.DEPTH_TEST):t.enable(t.DEPTH_TEST),this.noDepthSet?t.depthMask(!1):t.depthMask(this.depthMaskValue)}getAlpha(e,t,r,s){return this.getScalarValue(e,"KMTA",t,r,s,this.alpha)}getTextureId(e,t,r,s){return this.getScalarValue(e,"KMTF",t,r,s,this.textureId)}}class Xs{model;shader;layers;constructor(e,t,r){this.model=e,this.shader=t,this.layers=r}}class Ks extends Je{alpha;color;geosetId;constructor(e,t){super(e,t);const r=t.color;this.alpha=t.alpha,this.color=q(r[2],r[1],r[0]),this.geosetId=t.geosetId,this.addVariants("KGAO","alpha"),this.addVariants("KGAC","color")}getAlpha(e,t,r,s){return this.getScalarValue(e,"KGAO",t,r,s,this.alpha)}getColor(e,t,r,s){return this.getVectorValue(e,"KGAC",t,r,s,this.color)}}const Ur={1:"TeamColor/TeamColor00",2:"TeamGlow/TeamGlow00",11:"Cliff/Cliff0",21:"",31:"LordaeronTree/LordaeronSummerTree",32:"AshenvaleTree/AshenTree",33:"BarrensTree/BarrensTree",34:"NorthrendTree/NorthTree",35:"Mushroom/MushroomTree",36:"RuinsTree/RuinsTree",37:"OutlandMushroomTree/MushroomTree"};class be extends Je{index;name;objectId;parentId;pivot;dontInheritTranslation;dontInheritRotation;dontInheritScaling;billboarded;billboardedX;billboardedY;billboardedZ;cameraAnchored;anyBillboarding;constructor(e,t,r){super(e,t),this.index=r,this.name=t.name,this.objectId=t.objectId,this.parentId=t.parentId,this.pivot=e.pivotPoints[t.objectId]||M();const s=t.flags;this.dontInheritTranslation=(s&Se.DontInheritTranslation)>0,this.dontInheritRotation=(s&Se.DontInheritRotation)>0,this.dontInheritScaling=(s&Se.DontInheritScaling)>0,this.billboarded=(s&Se.Billboarded)>0,this.billboardedX=(s&Se.BillboardedLockX)>0,this.billboardedY=(s&Se.BillboardedLockY)>0,this.billboardedZ=(s&Se.BillboardedLockZ)>0,this.cameraAnchored=(s&Se.CameraAnchored)>0,this.anyBillboarding=this.billboarded||this.billboardedX||this.billboardedY||this.billboardedZ,t.objectId===t.parentId&&(this.parentId=-1),this.addVariants("KGTR","translation"),this.addVariants("KGRT","rotation"),this.addVariants("KGSC","scale"),this.addVariantIntersection(["translation","rotation","scale"],"generic")}getVisibility(e,t,r,s){return e[0]=1,-1}getTranslation(e,t,r,s){return this.getVectorValue(e,"KGTR",t,r,s,Ue)}getRotation(e,t,r,s){return this.getQuatValue(e,"KGRT",t,r,s,Dt)}getScale(e,t,r,s){return this.getVectorValue(e,"KGSC",t,r,s,Ot)}}class Ys extends be{geosetAnimation;constructor(e,t,r){super(e,t,r),this.geosetAnimation=e.geosetAnimations[t.geosetAnimationId]}getVisibility(e,t,r,s){return this.geosetAnimation?this.geosetAnimation.getAlpha(e,t,r,s):(e[0]=1,-1)}}class Ws extends be{type;attenuation;color;intensity;ambientColor;ambientIntensity;constructor(e,t,r){super(e,t,r),this.type=t.type,this.attenuation=t.attenuation,this.color=t.color,this.intensity=t.intensity,this.ambientColor=t.ambientColor,this.ambientIntensity=t.ambientIntensity}getAttenuationStart(e,t,r,s){return this.getScalarValue(e,"KLAS",t,r,s,this.attenuation[0])}getAttenuationEnd(e,t,r,s){return this.getScalarValue(e,"KLAE",t,r,s,this.attenuation[1])}getIntensity(e,t,r,s){return this.getScalarValue(e,"KLAI",t,r,s,this.intensity)}getColor(e,t,r,s){return this.getVectorValue(e,"KLAC",t,r,s,this.color)}getAmbientIntensity(e,t,r,s){return this.getScalarValue(e,"KLBI",t,r,s,this.ambientIntensity)}getAmbientColor(e,t,r,s){return this.getVectorValue(e,"KLBC",t,r,s,this.ambientColor)}}class $s extends be{}class Zs extends be{path;attachmentId;internalModel=null;constructor(e,t,r){super(e,t,r);const s=t.path.replace(/\\/g,"/").toLowerCase().replace(".mdl",".mdx");if(this.path=s,this.attachmentId=t.attachmentId,s!==""&&s.indexOf(".mdx")!=-1){const n=e.viewer.load(s,e.pathSolver,e.solverParams);n.then(o=>{o&&(this.internalModel=o)}),e.blockers.push(n)}}getVisibility(e,t,r,s){return this.getScalarValue(e,"KATV",t,r,s,1)}}class Qs extends be{internalModel=null;speed;latitude;longitude;lifeSpan;gravity;emissionRate;ok=!1;constructor(e,t,r){super(e,t,r),this.speed=t.speed,this.latitude=t.latitude,this.longitude=t.longitude,this.lifeSpan=t.lifeSpan,this.gravity=t.gravity,this.emissionRate=t.emissionRate,e.viewer.load(t.path.replace(/\\/g,"/").toLowerCase().replace(".mdl",".mdx"),e.pathSolver,e.solverParams).then(s=>{s&&(this.internalModel=s,this.ok=!0)})}getSpeed(e,t,r,s){return this.getScalarValue(e,"KPES",t,r,s,this.speed)}getLatitude(e,t,r,s){return this.getScalarValue(e,"KPLTV",t,r,s,this.latitude)}getLongitude(e,t,r,s){return this.getScalarValue(e,"KPLN",t,r,s,this.longitude)}getLifeSpan(e,t,r,s){return this.getScalarValue(e,"KPEL",t,r,s,this.lifeSpan)}getGravity(e,t,r,s){return this.getScalarValue(e,"KPEG",t,r,s,this.gravity)}getEmissionRate(e,t,r,s){return this.getScalarValue(e,"KPEE",t,r,s,this.emissionRate)}getVisibility(e,t,r,s){return this.getScalarValue(e,"KPEV",t,r,s,1)}}const Js=M(),en=M(),tn=M(),ce=60,Ut=ce>>2,Gr=0,rn=12,sn=24,nn=36,kr=48,Hr=52,jr=56,Gt=57,kt=Gr>>2,zr=kr>>2,on=Gt,qr=0,Mt=1,Xr=2,an=3,Kr=1e3,Ht=1e4,Yr=2;function ln(i,e){const t=i.instance,r=i.objects,s=e.byteView,n=e.floatView,o=i.emitterObject,a=o.modelSpace,l=o.tailLength,c=i.node,u=t.teamColor;let h=0;for(const f of r){const d=h*ce,m=h*Ut,v=m+kt;let p=f.location;const b=f.scale,g=f.tail;if(g===qe.Head)a&&(p=we(Js,p,c.worldMatrix)),n[v+0]=p[0],n[v+1]=p[1],n[v+2]=p[2],n[v+3]=f.facing;else{const E=f.velocity;let T=en,_=p;T[0]=_[0]-l*E[0],T[1]=_[1]-l*E[1],T[2]=_[2]-l*E[2],a&&(T=we(T,T,c.worldMatrix),_=we(tn,_,c.worldMatrix)),n[v+0]=T[0],n[v+1]=T[1],n[v+2]=T[2],n[v+3]=_[0],n[v+4]=_[1],n[v+5]=_[2]}n[v+6]=b[0],n[v+7]=b[0],n[v+8]=b[0],n[m+zr]=f.health,s[d+jr]=g,s[d+on]=u,h+=1}}function cn(i,e){const t=i.instance,r=t.textureOverrides,n=t.scene.camera,o=i.emitterObject,a=o.model,l=a.viewer,c=l.gl,u=l.sharedCache.get("mdx"),h=e.uniforms,f=o.colors,d=o.intervals,m=o.replaceableId;let v,p=o.internalTexture;c.blendFunc(o.blendSrc,o.blendDst),c.uniform1f(h.u_filterMode,o.filterMode),o.internalTexture?p=o.internalTexture:m===1?p=u.teamColors[t.teamColor]:m===2?p=u.teamGlows[t.teamColor]:p=a.textures[o.textureId];let b=r.get(Kr+o.index);b||(m===0&&(b=r.get(o.textureId)),b||(b=p.texture)),l.webgl.bindTextureAndWrap(b,0,p.wrapS,p.wrapT),o.xYQuad?v=n.vectors:v=n.billboardedVectors,c.uniform1f(h.u_lifeSpan,o.lifeSpan),c.uniform1f(h.u_timeMiddle,o.timeMiddle),c.uniform1f(h.u_columns,o.columns),c.uniform1f(h.u_rows,o.rows),c.uniform1f(h.u_teamColored,o.teamColored),c.uniform3fv(h["u_intervals[0]"],d[0]),c.uniform3fv(h["u_intervals[1]"],d[1]),c.uniform3fv(h["u_intervals[2]"],d[2]),c.uniform3fv(h["u_intervals[3]"],d[3]),c.uniform4fv(h["u_colors[0]"],f[0]),c.uniform4fv(h["u_colors[1]"],f[1]),c.uniform4fv(h["u_colors[2]"],f[2]),c.uniform3fv(h.u_scaling,o.scaling),o.head&&(c.uniform3fv(h["u_vertices[0]"],v[0]),c.uniform3fv(h["u_vertices[1]"],v[1]),c.uniform3fv(h["u_vertices[2]"],v[2]),c.uniform3fv(h["u_vertices[3]"],v[3])),o.tail&&c.uniform3fv(h.u_cameraZ,n.directionZ)}function hn(i,e){let t=i.first;const r=e.byteView,s=e.floatView,o=i.emitterObject.columns,l=1/(i.alive-1);let c=0;for(;t.next;){const u=t.next.vertices,h=c*ce,d=c*Ut+kt,m=h+Hr,v=h+Gt,p=(t.slot%o+(1-c*l-l))/o,b=t.slot/o,g=p+l,E=t.vertices,T=t.color;s[d+0]=E[0],s[d+1]=E[1],s[d+2]=E[2],s[d+3]=E[3],s[d+4]=E[4],s[d+5]=E[5],s[d+6]=u[3],s[d+7]=u[4],s[d+8]=u[5],s[d+9]=u[0],s[d+10]=u[1],s[d+11]=u[2],r[m+0]=T[0],r[m+1]=T[1],r[m+2]=T[2],r[m+3]=T[3],r[v+0]=p*255,r[v+1]=g*255,r[v+2]=b*255,t=t.next,c+=1}}function un(i,e){const t=i.instance.textureOverrides,r=i.emitterObject,s=r.layer,n=r.model,o=n.viewer.gl,a=e.uniforms,l=n.textures[s.textureId],c=t.get(s.textureId)||l.texture;s.bind(e),o.uniform1f(a.u_filterMode,s.filterMode),n.viewer.webgl.bindTextureAndWrap(c,0,l.wrapS,l.wrapT),o.uniform1f(a.u_columns,r.columns),o.uniform1f(a.u_rows,r.rows)}function rr(i,e){const t=i.objects,r=e.floatView;let s=0;for(const n of t){const o=s*Ut,a=o+kt,l=n.vertices;r[a+0]=l[0],r[a+1]=l[1],r[a+2]=l[2],r[a+3]=l[3],r[a+4]=l[4],r[a+5]=l[5],r[a+6]=l[6],r[a+7]=l[7],r[a+8]=l[8],r[a+9]=l[9],r[a+10]=l[10],r[a+11]=l[11],r[o+zr]=n.health,s+=1}}function fn(i,e){const t=i.instance.textureOverrides,r=i.emitterObject,s=r.intervalTimes,n=r.intervals,o=r.colors,a=r.model,l=a.viewer.gl,c=e.uniforms,u=r.internalTexture,h=t.get(Ht+r.index)||u.texture;l.blendFunc(r.blendSrc,r.blendDst),a.viewer.webgl.bindTextureAndWrap(h,0,u.wrapS,u.wrapT),l.uniform1f(c.u_lifeSpan,r.lifeSpan),l.uniform1f(c.u_columns,r.columns),l.uniform1f(c.u_rows,r.rows),l.uniform3f(c.u_intervalTimes,s[0],s[1],0),l.uniform3fv(c["u_intervals[0]"],n[0]),l.uniform3fv(c["u_intervals[1]"],n[1]),l.uniform4fv(c["u_colors[0]"],o[0]),l.uniform4fv(c["u_colors[1]"],o[1]),l.uniform4fv(c["u_colors[2]"],o[2])}function dn(i,e){const t=i.instance.textureOverrides,r=i.emitterObject,s=r.intervalTimes,n=r.colors,o=r.model,l=o.viewer.gl,c=e.uniforms,u=r.internalTexture,h=t.get(Ht+r.index)||u.texture;l.blendFunc(r.blendSrc,r.blendDst),o.viewer.webgl.bindTextureAndWrap(h,0,u.wrapS,u.wrapT),l.uniform1f(c.u_lifeSpan,r.lifeSpan),l.uniform1f(c.u_columns,r.columns),l.uniform1f(c.u_rows,r.rows),l.uniform3fv(c.u_intervalTimes,s),l.uniform4fv(c["u_colors[0]"],n[0]),l.uniform4fv(c["u_colors[1]"],n[1]),l.uniform4fv(c["u_colors[2]"],n[2])}function mn(i,e){let t=i.alive;const s=i.emitterObject.geometryEmitterType;if(s===Mt&&(t-=1),t>0){const n=i.instance.model.viewer,o=n.buffer,a=n.gl,l=n.webgl.extensions.ANGLE_instanced_arrays,c=t*ce,u=e.attribs;o.reserve(c),s===qr?(ln(i,o),cn(i,e)):s===Mt?(hn(i,o),un(i,e)):s===Xr?(rr(i,o),fn(i,e)):(rr(i,o),dn(i,e)),o.bindAndUpdate(c),a.uniform1i(e.uniforms.u_emitter,s),a.vertexAttribPointer(u.a_p0,3,a.FLOAT,!1,ce,Gr),a.vertexAttribPointer(u.a_p1,3,a.FLOAT,!1,ce,rn),a.vertexAttribPointer(u.a_p2,3,a.FLOAT,!1,ce,sn),a.vertexAttribPointer(u.a_p3,3,a.FLOAT,!1,ce,nn),a.vertexAttribPointer(u.a_health,1,a.FLOAT,!1,ce,kr),a.vertexAttribPointer(u.a_color,4,a.UNSIGNED_BYTE,!0,ce,Hr),a.vertexAttribPointer(u.a_tail,1,a.UNSIGNED_BYTE,!1,ce,jr),a.vertexAttribPointer(u.a_leftRightTop,3,a.UNSIGNED_BYTE,!1,ce,Gt),l.drawArraysInstancedANGLE(a.TRIANGLES,0,6,t)}}class Qe{texture=null;replaceableId;wrapS=33071;wrapT=33071;constructor(e,t){this.replaceableId=e,t&Ve.WrapWidth&&(this.wrapS=10497),t&Ve.WrapHeight&&(this.wrapT=10497)}}class Wr extends be{geometryEmitterType=qr;width;length;speed;latitude;gravity;emissionRate;squirt;lifeSpan;variation;tailLength;timeMiddle;columns;rows;teamColored=0;internalTexture=null;replaceableId;textureId;head;tail;cellWidth;cellHeight;colors=[];scaling;intervals;filterMode;blendSrc;blendDst;priorityPlane;lineEmitter;unfogged;modelSpace;xYQuad;ok=!0;constructor(e,t,r){super(e,t,r),this.width=t.width,this.length=t.length,this.speed=t.speed,this.latitude=t.latitude,this.gravity=t.gravity,this.emissionRate=t.emissionRate*Yr,this.squirt=t.squirt,this.lifeSpan=t.lifeSpan,this.variation=t.variation,this.tailLength=t.tailLength,this.timeMiddle=t.timeMiddle;const s=t.flags;this.lineEmitter=s&et.LineEmitter,this.unfogged=s&et.Unfogged,this.modelSpace=s&et.ModelSpace,this.xYQuad=s&et.XYQuad;const n=t.replaceableId;if(this.columns=t.columns,this.rows=t.rows,n===1||n===2)this.teamColored=1;else if(n>2){const f=e.reforged?".dds":".blp";this.internalTexture=new Qe(n,Ve.RepeatBoth),e.viewer.load(`ReplaceableTextures\\${Ur[n]}${f}`,e.pathSolver,e.solverParams).then(d=>{d&&(this.internalTexture.texture=d)})}this.replaceableId=t.replaceableId,this.textureId=t.textureId;const o=t.headOrTail;this.head=o===qe.Head||o===qe.Both,this.tail=o===qe.Tail||o===qe.Both,this.cellWidth=1/t.columns,this.cellHeight=1/t.rows;const a=t.segmentColors,l=t.segmentAlphas;for(let f=0;f<3;f++){const d=a[f];this.colors[f]=new Float32Array([d[0],d[1],d[2],l[f]/255])}this.scaling=t.segmentScaling;const c=t.headIntervals,u=t.tailIntervals;this.intervals=[new Float32Array(c[0]),new Float32Array(c[1]),new Float32Array(u[0]),new Float32Array(u[1])];const h=Br(t.filterMode,this.model.viewer.gl);this.filterMode=t.filterMode,this.blendSrc=h[0],this.blendDst=h[1],this.priorityPlane=t.priorityPlane}getWidth(e,t,r,s){return this.getScalarValue(e,"KP2N",t,r,s,this.width)}getLength(e,t,r,s){return this.getScalarValue(e,"KP2W",t,r,s,this.length)}getSpeed(e,t,r,s){return this.getScalarValue(e,"KP2S",t,r,s,this.speed)}getLatitude(e,t,r,s){return this.getScalarValue(e,"KP2L",t,r,s,this.latitude)}getGravity(e,t,r,s){return this.getScalarValue(e,"KP2G",t,r,s,this.gravity)}getEmissionRate(e,t,r,s){return this.getScalarValue(e,"KP2E",t,r,s,this.emissionRate)}getVariation(e,t,r,s){return this.getScalarValue(e,"KP2R",t,r,s,this.variation)}getVisibility(e,t,r,s){return this.getScalarValue(e,"KP2V",t,r,s,1)}}class $r extends be{geometryEmitterType=Mt;layer;heightAbove;heightBelow;alpha;color;lifeSpan;textureSlot;emissionRate;gravity;columns;rows;ok=!0;constructor(e,t,r){super(e,t,r),this.layer=e.materials[t.materialId].layers[0],this.heightAbove=t.heightAbove,this.heightBelow=t.heightBelow,this.alpha=t.alpha,this.color=t.color,this.lifeSpan=t.lifeSpan,this.textureSlot=t.textureSlot,this.emissionRate=t.emissionRate*Yr,this.gravity=t.gravity,this.columns=t.columns,this.rows=t.rows}getHeightBelow(e,t,r,s){return this.getScalarValue(e,"KRHB",t,r,s,this.heightBelow)}getHeightAbove(e,t,r,s){return this.getScalarValue(e,"KRHA",t,r,s,this.heightAbove)}getTextureSlot(e,t,r,s){return this.getScalarValue(e,"KRTX",t,r,s,0)}getColor(e,t,r,s){return this.getVectorValue(e,"KRCO",t,r,s,this.color)}getAlpha(e,t,r,s){return this.getScalarValue(e,"KRAL",t,r,s,this.alpha)}getVisibility(e,t,r,s){const n=this.getAlpha(e,t,r,s);return e[0]===0?n:this.getScalarValue(e,"KRVS",t,r,s,1)}}class vn extends Je{name;position;fieldOfView;farClippingPlane;nearClippingPlane;targetPosition;constructor(e,t){super(e,t),this.name=t.name,this.position=t.position,this.fieldOfView=t.fieldOfView,this.farClippingPlane=t.farClippingPlane,this.nearClippingPlane=t.nearClippingPlane,this.targetPosition=t.targetPosition}getTranslation(e,t,r,s){return this.getVectorValue(e,"KCTR",t,r,s,Ue)}getTargetTranslation(e,t,r,s){return this.getVectorValue(e,"KTTR",t,r,s,Ue)}getRotation(e,t,r,s){return this.getScalarValue(e,"KCRL",t,r,s,0)}}class pn extends be{geometryEmitterType=-1;type;id;tracks;globalSequence=-1;defval=new Uint32Array(1);internalModel=null;internalTexture=null;colors=[];intervalTimes=new Float32Array(3);scale=0;columns=0;rows=0;lifeSpan=0;blendSrc=0;blendDst=0;intervals=[];distanceCutoff=0;maxDistance=0;minDistance=0;pitch=0;pitchVariance=0;volume=0;decodedBuffers=[];ok=!1;constructor(e,t,r){super(e,t,r);const s=e.viewer,n=t.name;let o=n.substring(0,3);const a=n.substring(4);o==="FPT"&&(o="SPL"),o==="SPL"?this.geometryEmitterType=Xr:o==="UBR"&&(this.geometryEmitterType=an),this.type=o,this.id=a,this.tracks=t.tracks;const l=t.globalSequenceId;if(l!==-1&&(this.globalSequence=e.globalSequences[l]),o==="SND"&&!s.audioEnabled)return;const c=s.promise();jt.getEventObjectData(s,o,a,e.hd).then(u=>{if(c(),u){const{row:h,resources:f}=u;if(this.ok=!0,o==="SPN")this.internalModel=f[0];else if(o==="SPL"||o==="UBR"){this.internalTexture=new Qe(0,Ve.WrapBoth),this.internalTexture.texture=f[0],this.scale=h.number("Scale"),this.colors[0]=new Float32Array([h.number("StartR"),h.number("StartG"),h.number("StartB"),h.number("StartA")]),this.colors[1]=new Float32Array([h.number("MiddleR"),h.number("MiddleG"),h.number("MiddleB"),h.number("MiddleA")]),this.colors[2]=new Float32Array([h.number("EndR"),h.number("EndG"),h.number("EndB"),h.number("EndA")]),o==="SPL"?(this.columns=h.number("Columns"),this.rows=h.number("Rows"),this.lifeSpan=h.number("Lifespan")+h.number("Decay"),this.intervalTimes[0]=h.number("Lifespan"),this.intervalTimes[1]=h.number("Decay"),this.intervals[0]=new Float32Array([h.number("UVLifespanStart"),h.number("UVLifespanEnd"),h.number("LifespanRepeat")]),this.intervals[1]=new Float32Array([h.number("UVDecayStart"),h.number("UVDecayEnd"),h.number("DecayRepeat")])):(this.columns=1,this.rows=1,this.lifeSpan=h.number("BirthTime")+h.number("PauseTime")+h.number("Decay"),this.intervalTimes[0]=h.number("BirthTime"),this.intervalTimes[1]=h.number("PauseTime"),this.intervalTimes[2]=h.number("Decay"));const d=Br(h.number("BlendMode"),s.gl);this.blendSrc=d[0],this.blendDst=d[1]}else{this.distanceCutoff=h.number("DistanceCutoff"),this.maxDistance=h.number("MaxDistance"),this.minDistance=h.number("MinDistance"),this.pitch=h.number("Pitch"),this.pitchVariance=h.number("PitchVariance"),this.volume=h.number("Volume");for(const d of f)this.decodedBuffers.push(d.data)}}})}getValue(e,t){if(this.globalSequence!==-1){const r=this.globalSequence;return this.getValueAtTime(e,t.counter%r,0,r)}else if(t.sequence!==-1){const r=this.model.sequences[t.sequence].interval;return this.getValueAtTime(e,t.frame,r[0],r[1])}else return e[0]=this.defval[0],-1}getValueAtTime(e,t,r,s){const n=this.tracks;if(t>=r&&t<=s)for(let o=n.length-1;o>-1;o--){if(n[o]<r)return e[0]=0,o;if(n[o]<=t)return e[0]=1,o}return e[0]=0,-1}}class bn extends be{type;vertices;boundsRadius;constructor(e,t,r){super(e,t,r),this.type=t.type,this.vertices=t.vertices,this.boundsRadius=t.boundsRadius}}var K=(i=>(i[i.VertexGroups=0]="VertexGroups",i[i.ExtendedVertexGroups=1]="ExtendedVertexGroups",i[i.Skin=2]="Skin",i))(K||{});class Ge{index;geoset;layer;material;skinningType;isHd;constructor(e,t,r,s,n){let o,a;n?(o=r,a=o.layers[0]):(o=null,a=r),this.index=e,this.geoset=t,this.skinningType=s,this.isHd=n,this.layer=a,this.material=o}}class gn{model;index;positionOffset;normalOffset;uvOffset;tangentOffset;skinOffset;faceOffset;vertices;elements;faceType;geosetAnimation=null;constructor(e,t,r,s,n,o,a,l,c,u,h){this.model=e,this.index=t,this.positionOffset=r,this.normalOffset=s,this.uvOffset=n,this.tangentOffset=o,this.skinOffset=a,this.faceOffset=l,this.vertices=c,this.elements=u,this.faceType=h;for(const f of e.geosetAnimations)f.geosetId===t&&(this.geosetAnimation=f)}bindShared(e,t,r){e.vertexAttribPointer(t.a_position,3,e.FLOAT,!1,0,this.positionOffset),e.vertexAttribPointer(t.a_normal,3,e.FLOAT,!1,0,this.normalOffset),e.vertexAttribPointer(t.a_uv,2,e.FLOAT,!1,0,this.uvOffset+r*this.vertices*8)}bindVertexGroups(e,t){const r=this.model,s=r.skinDataType,n=r.bytesPerSkinElement;e.vertexAttribPointer(t.a_bones,4,s,!1,5*n,this.skinOffset),e.vertexAttribPointer(t.a_boneNumber,1,s,!1,5*n,this.skinOffset+4*n)}bindVertexGroupsExtended(e,t){const r=this.model,s=r.skinDataType,n=r.bytesPerSkinElement;e.vertexAttribPointer(t.a_bones,4,s,!1,9*n,this.skinOffset),e.vertexAttribPointer(t.a_extendedBones,4,s,!1,9*n,this.skinOffset+4*n),e.vertexAttribPointer(t.a_boneNumber,1,s,!1,9*n,this.skinOffset+8*n)}bindSkin(e,t){e.vertexAttribPointer(t.a_bones,4,e.UNSIGNED_BYTE,!1,8,this.skinOffset),e.vertexAttribPointer(t.a_weights,4,e.UNSIGNED_BYTE,!0,8,this.skinOffset+4)}bind(e,t){const r=this.model.viewer.gl,s=e.attribs;this.bindShared(r,s,t),s.a_weights!==void 0?this.bindSkin(r,s):this.bindVertexGroups(r,s)}bindExtended(e,t){const r=this.model.viewer.gl,s=e.attribs;this.bindShared(r,s,t),this.bindVertexGroupsExtended(r,s)}bindHd(e,t,r){const s=this.model.viewer.gl,n=e.attribs;this.bindShared(s,n,r),s.vertexAttribPointer(n.a_tangent,4,s.FLOAT,!1,0,this.tangentOffset),t===K.Skin?this.bindSkin(s,n):t===K.ExtendedVertexGroups?this.bindVertexGroupsExtended(s,n):this.bindVertexGroups(s,n)}render(){const e=this.model.viewer.gl;e.drawElements(this.faceType,this.elements,e.UNSIGNED_SHORT,this.faceOffset)}}function xn(i,e){if(e.length>0){const t=i.viewer.gl;let r=0,s=0,n=0,o=0,a=0,l=0;const c=[];for(let g=0,E=e.length;g<E;g++){const T=e[g];if(T.lod===0||T.lod===-1){const _=T.vertices.length/3;if(r+=_*12,s+=_*12,n+=T.uvSets.length*_*8,T.tangents.length&&(o+=_*16),T.skin.length)a+=_*8,c[g]=K.Skin;else{let x=0;for(const L of T.matrixGroups)L>x&&(x=L);x>4?(a+=_*9,c[g]=K.ExtendedVertexGroups):(a+=_*5,c[g]=K.VertexGroups)}l+=T.faces.byteLength}}let u=0,h=u+r,f=h+s,d=f+n,m=d+o,v=0,p=Uint8Array,b=t.UNSIGNED_BYTE;i.bones.length>255&&(a*=2,p=Uint16Array,b=t.UNSIGNED_SHORT),i.skinDataType=b,i.bytesPerSkinElement=p.BYTES_PER_ELEMENT,i.arrayBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,i.arrayBuffer),t.bufferData(t.ARRAY_BUFFER,m+a,t.STATIC_DRAW),i.elementBuffer=t.createBuffer(),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,i.elementBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,l,t.STATIC_DRAW);for(let g=0,E=e.length;g<E;g++){const T=e[g];if(T.lod===0||T.lod===-1){const _=T.vertices,x=T.normals,L=T.uvSets,F=T.tangents,V=T.faces;let N;const k=T.vertices.length/3,C=c[g];if(C===K.Skin)N=T.skin;else{const U=T.matrixIndices,y=T.vertexGroups,I=[];let O=0,D=4;C===K.ExtendedVertexGroups&&(D=8),N=new p(k*(D+1));for(const z of T.matrixGroups)I.push(U.subarray(O,O+z)),O+=z;for(let z=0;z<k;z++){const ae=I[y[z]];if(O=z*(D+1),ae){const fe=Math.min(ae.length,D);for(let S=0;S<fe;S++)N[O+S]=ae[S]+1;N[O+D]=fe}}}const B=new gn(i,i.geosets.length,u,h,f,d,m,v,k,V.length,T.faceTypeGroups[0]);i.geosets.push(B);const R=i.materials[T.materialId];if(R.shader==="Shader_HD_DefaultUnit")i.batches.push(new Ge(i.batches.length,B,R,C,!0));else for(const U of R.layers)i.batches.push(new Ge(i.batches.length,B,U,C,!1));t.bufferSubData(t.ARRAY_BUFFER,u,_),u+=_.byteLength,t.bufferSubData(t.ARRAY_BUFFER,h,x),h+=x.byteLength;for(const U of L)t.bufferSubData(t.ARRAY_BUFFER,f,U),f+=U.byteLength;F.length&&(t.bufferSubData(t.ARRAY_BUFFER,d,F),d+=F.byteLength),t.bufferSubData(t.ARRAY_BUFFER,m,N),m+=N.byteLength,t.bufferSubData(t.ELEMENT_ARRAY_BUFFER,v,V),v+=V.byteLength}}}}class Zr{model;skinningType;isHd;objects=[];constructor(e,t,r){this.model=e,this.skinningType=t,this.isHd=r}render(e){const t=e.scene,r=t.camera,s=e.textureOverrides,n=e.layerAlphas,o=this.model,a=o.textures,l=o.batches,c=o.viewer,u=c.sharedCache.get("mdx"),h=c.gl,f=c.webgl,d=this.skinningType,m=this.isHd,v=u.teamColors,p=u.teamGlows,b=jt.getBatchShader(c,d,m);b.use();const g=b.uniforms;h.uniformMatrix4fv(g.u_VP,!1,r.viewProjectionMatrix);const E=e.boneTexture;if(E?(E.bind(15),h.uniform1f(g.u_hasBones,1),h.uniform1i(g.u_boneMap,15),h.uniform1f(g.u_vectorSize,1/E.width),h.uniform1f(g.u_rowSize,1)):h.uniform1f(g.u_hasBones,0),h.uniform3fv(g.u_lightPos,t.lightPosition),h.bindBuffer(h.ARRAY_BUFFER,o.arrayBuffer),h.bindBuffer(h.ELEMENT_ARRAY_BUFFER,o.elementBuffer),m){h.uniform1i(g.u_diffuseMap,0),h.uniform1i(g.u_normalsMap,1),h.uniform1i(g.u_ormMap,2),h.uniform1i(g.u_emissiveMap,3),h.uniform1i(g.u_teamColorMap,4),h.uniform1i(g.u_environmentMap,5),h.disable(h.BLEND),h.enable(h.DEPTH_TEST),h.depthMask(!0),h.uniformMatrix4fv(g.u_MV,!1,r.viewMatrix),h.uniform3fv(g.u_eyePos,r.location);for(const T of this.objects){const _=l[T],x=_.geoset,L=_.material,[F,V,N,k,C,B]=L.layers,R=n[F.index];if(R>0){h.uniform1f(g.u_layerAlpha,R),h.uniform1f(g.u_filterMode,F.filterMode);const w=F.textureId,U=V.textureId,y=N.textureId,I=k.textureId,O=C.textureId,D=B.textureId,z=a[w],ae=a[U],fe=a[y],S=a[I];let A=a[O];const G=a[D];(A.replaceableId===0||A.replaceableId===1)&&(A=v[e.teamColor]);const ie=s.get(w)||z.texture,H=s.get(U)||ae.texture,Z=s.get(y)||fe.texture,ee=s.get(I)||S.texture,Q=s.get(O)||A.texture,He=s.get(D)||G.texture;f.bindTextureAndWrap(ie,0,z.wrapS,z.wrapT),f.bindTextureAndWrap(H,1,ae.wrapS,ae.wrapT),f.bindTextureAndWrap(Z,2,fe.wrapS,fe.wrapT),f.bindTextureAndWrap(ee,3,S.wrapS,S.wrapT),f.bindTextureAndWrap(Q,4,A.wrapS,A.wrapT),f.bindTextureAndWrap(He,5,G.wrapS,G.wrapT),x.bindHd(b,_.skinningType,F.coordId),x.render()}}}else{const T=e.geosetColors,_=e.layerTextures,x=e.uvAnims;h.uniform4fv(g.u_vertexColor,e.vertexColor),h.uniform1i(g.u_texture,0);for(const L of this.objects){const F=l[L],V=F.geoset,N=F.layer,k=V.index,C=N.index,B=T[k],R=n[C];if(B[3]>.01&&R>.01){const w=_[C],U=a[w],y=x[C];h.uniform4fv(g.u_geosetColor,B),h.uniform1f(g.u_layerAlpha,R),h.uniform1f(g.u_unshaded,N.unshaded),h.uniform2f(g.u_uvTrans,y[0],y[1]),h.uniform2f(g.u_uvRot,y[2],y[3]),h.uniform1f(g.u_uvScale,y[4]),N.bind(b);let I=s.get(w);if(!I){const O=U.replaceableId;let D;O===1?D=v[e.teamColor]:O===2?D=p[e.teamColor]:D=U,D&&(I=D.texture)}f.bindTextureAndWrap(I,0,U.wrapS,U.wrapT),d===K.ExtendedVertexGroups?V.bindExtended(b,N.coordId):V.bind(b,N.coordId),V.render()}}}}}class _n{model;objects=[];constructor(e){this.model=e}render(e){const t=e.scene,r=e.nodes,n=e.model.viewer,o=n.gl,a=n.webgl.extensions.ANGLE_instanced_arrays,l=n.sharedCache.get("mdx"),c=l.particlesShader,u=c.uniforms,h=c.attribs,f=l.rectBuffer;o.depthMask(!1),o.enable(o.BLEND),o.disable(o.CULL_FACE),o.enable(o.DEPTH_TEST),c.use(),o.uniformMatrix4fv(u.u_VP,!1,t.camera.viewProjectionMatrix),o.uniform1i(u.u_texture,0),a.vertexAttribDivisorANGLE(h.a_position,0),o.bindBuffer(o.ARRAY_BUFFER,f),o.vertexAttribPointer(h.a_position,1,o.UNSIGNED_BYTE,!1,0,0),a.vertexAttribDivisorANGLE(h.a_p0,1),a.vertexAttribDivisorANGLE(h.a_p1,1),a.vertexAttribDivisorANGLE(h.a_p2,1),a.vertexAttribDivisorANGLE(h.a_p3,1),a.vertexAttribDivisorANGLE(h.a_health,1),a.vertexAttribDivisorANGLE(h.a_color,1),a.vertexAttribDivisorANGLE(h.a_tail,1),a.vertexAttribDivisorANGLE(h.a_leftRightTop,1);for(const d of this.objects)mn(r[d].object,c);a.vertexAttribDivisorANGLE(h.a_leftRightTop,0),a.vertexAttribDivisorANGLE(h.a_tail,0),a.vertexAttribDivisorANGLE(h.a_color,0),a.vertexAttribDivisorANGLE(h.a_health,0),a.vertexAttribDivisorANGLE(h.a_p3,0),a.vertexAttribDivisorANGLE(h.a_p2,0),a.vertexAttribDivisorANGLE(h.a_p1,0),a.vertexAttribDivisorANGLE(h.a_p0,0)}}function ir(i){return i instanceof Ge||i instanceof $r?i.layer.priorityPlane:i instanceof Wr?i.priorityPlane:0}function sr(i,e){return i instanceof Zr?e instanceof Ge&&e.skinningType===i.skinningType&&e.isHd===i.isHd:e instanceof be}function nr(i,e){return e instanceof Ge?new Zr(i,e.skinningType,e.isHd):new _n(i)}function Tn(i){const e=[];let t=[];for(const a of i.batches)a.layer.filterMode<2?e.push(a):t.push(a);const r=i.opaqueGroups,s=i.translucentGroups;let n=null;for(const a of e)(!n||!sr(n,a))&&(n=nr(i,a),r.push(n)),n.objects.push(a.index);t=t.sort((a,l)=>a.layer.filterMode-l.layer.filterMode);const o=[...t,...i.eventObjects,...i.particleEmitters2,...i.ribbonEmitters].sort((a,l)=>ir(a)-ir(l));n=null;for(const a of o)(a instanceof Ge||a.geometryEmitterType!==-1)&&((!n||!sr(n,a))&&(n=nr(i,a),s.push(n)),n.objects.push(a.index))}class En extends Nr{convertBasis(e){Pt(e,e,-Math.PI/2),Sr(e,e,-Math.PI/2)}}const or=new Float32Array(1);class wn{instance;attachment;internalInstance;constructor(e,t){const s=t.internalModel.addInstance();s.setSequenceLoopMode(2),s.dontInheritScaling=!1,s.hide(),s.setParent(e.nodes[t.objectId]),this.instance=e,this.attachment=t,this.internalInstance=s}update(){const e=this.instance,t=this.internalInstance;e.scene&&e.sequence!==-1&&(this.attachment.getVisibility(or,e.sequence,e.frame,e.counter),or[0]>.1?(e.scene.addInstance(t),t.hidden()&&(t.show(),t.setSequence(0))):t.hide())}}class Sn{instance;objects=[];alive=0;currentEmission=0;constructor(e){this.instance=e}update(e){this.updateEmission(e);const t=this.currentEmission;if(t>=1)for(let r=0;r<t;r+=1)this.emit()}clear(){const e=this.objects;for(let t=0,r=this.alive;t<r;t++){const s=e[t];s.health=0}this.currentEmission=0}emitObject(e){const t=this.objects;this.alive===t.length&&t.push(this.createObject());const r=t[this.alive];return r.index=this.alive,r.bind(e),this.alive+=1,this.currentEmission-=1,this.instance.scene.emittedObjectUpdater.add(r),r}kill(e){const t=this.objects;this.alive-=1;const r=t[this.alive];t[e.index]=r,t[this.alive]=e,r.index=e.index,e.index=-1}}class bt extends Sn{emitterObject;constructor(e,t){super(e),this.emitterObject=t}update(e){this.emitterObject.ok&&super.update(e)}}class ke{emitter;index=-1;health=0;constructor(e){this.emitter=e}}const Re=$(),yn=M(),_t=new Float32Array(1),ar=new Float32Array(1),lr=new Float32Array(1),cr=new Float32Array(1);class An extends ke{internalInstance;velocity=M();gravity=0;constructor(e){super(e);const r=e.emitterObject.internalModel;this.internalInstance=r.addInstance()}bind(){const e=this.emitter,t=e.instance,r=t.sequence,s=t.frame,n=t.counter,o=t.scene,a=e.emitterObject,l=t.nodes[a.index],c=this.internalInstance,u=l.worldScale,h=this.velocity;a.getLatitude(_t,r,s,n),a.getLifeSpan(ar,r,s,n),a.getGravity(lr,r,s,n),a.getSpeed(cr,r,s,n),this.health=ar[0],this.gravity=lr[0]*u[2],It(Re),yr(Re,Re,ye(-Math.PI,Math.PI)),Pt(Re,Re,ye(-_t[0],_t[0])),he(h,Ze,Re),he(h,h,l.worldRotation),vt(h,h,cr[0]),$e(h,h,u),c.setScene(o),c.setSequence(0),c.setTransformation(l.worldLocation,Ne(Re,Ze,ye(0,Math.PI*2)),l.worldScale),c.show()}update(e){const t=this.internalInstance;if(this.health-=e,this.health>0){const r=this.velocity;r[2]-=this.gravity*e,t.move(vt(yn,r,e))}else t.hide()}}const hr=new Float32Array(1);class Rn extends bt{updateEmission(e){const t=this.instance;t.allowParticleSpawn&&(this.emitterObject.getEmissionRate(hr,t.sequence,t.frame,t.counter),this.currentEmission+=hr[0]*e)}emit(){this.emitObject()}createObject(){return new An(this)}}const de=$(),ur=new Float32Array(1),fr=new Float32Array(1),dr=new Float32Array(1),mr=new Float32Array(1),vr=new Float32Array(1),pr=new Float32Array(1);class Cn extends ke{tail=0;gravity=0;location=M();velocity=M();scale=M();facing=0;bind(e){const t=this.emitter,r=t.instance,s=r.sequence,n=r.frame,o=r.counter,a=t.emitterObject;a.getWidth(ur,s,n,o),a.getLength(fr,s,n,o),a.getLatitude(dr,s,n,o),a.getVariation(mr,s,n,o),a.getSpeed(vr,s,n,o),a.getGravity(pr,s,n,o);const l=t.node,c=l.pivot,u=l.worldScale,h=ur[0]*.5,f=fr[0]*.5,d=si(dr[0]),m=mr[0],v=vr[0],p=this.location,b=this.velocity;this.health=a.lifeSpan,this.tail=e,this.gravity=pr[0]*u[2],oe(this.scale,u),p[0]=c[0]+ye(-h,h),p[1]=c[1]+ye(-f,f),p[2]=c[2],a.modelSpace||we(p,p,l.worldMatrix),It(de),yr(de,de,Math.PI/2),Pt(de,de,ye(-d,d)),a.lineEmitter||Sr(de,de,ye(-d,d)),a.modelSpace||re(de,l.worldRotation,de),he(b,Ze,de),vt(b,b,v*(1+ye(-m,m))),a.modelSpace||$e(b,b,u),a.xYQuad&&(this.facing=Math.atan2(b[1],b[0])-Math.PI+Math.PI/8)}update(e){if(this.health-=e,this.health>0){const t=this.location,r=this.velocity;r[2]-=this.gravity*e,t[0]+=r[0]*e,t[1]+=r[1]*e,t[2]+=r[2]*e}}}const Tt=new Float32Array(1);class Mn extends bt{node;lastEmissionKey=-1;constructor(e,t){super(e,t),this.node=e.nodes[t.index]}updateEmission(e){const t=this.instance;if(t.allowParticleSpawn){const r=this.emitterObject,s=r.getEmissionRate(Tt,t.sequence,t.frame,t.counter);r.squirt?(s!==this.lastEmissionKey&&(this.currentEmission+=Tt[0]),this.lastEmissionKey=s):this.currentEmission+=Tt[0]*e}}emit(){const e=this.emitterObject;e.head&&this.emitObject(0),e.tail&&this.emitObject(1)}createObject(){return new Cn(this)}}const me=M(),ve=M(),ht=new Float32Array(3),br=new Float32Array(1),gr=new Uint32Array(1);class Ln extends ke{vertices=new Float32Array(6);color=new Uint8Array(4);slot=0;prev=null;next=null;bind(){const e=this.emitter,t=e.instance,r=t.sequence,s=t.frame,n=t.counter,o=e.emitterObject,a=t.nodes[o.index],[l,c,u]=a.pivot,h=a.worldMatrix,f=this.vertices;this.health=e.emitterObject.lifeSpan,o.getHeightBelow(me,r,s,n),o.getHeightAbove(ve,r,s,n),me[1]=c-me[0],me[0]=l,me[2]=u,ve[1]=c+ve[0],ve[0]=l,ve[2]=u,we(me,me,h),we(ve,ve,h),f[0]=ve[0],f[1]=ve[1],f[2]=ve[2],f[3]=me[0],f[4]=me[1],f[5]=me[2]}update(e){if(this.health-=e,this.health>0){const t=this.emitter,r=t.instance,s=r.sequence,n=r.frame,o=r.counter,a=t.emitterObject,l=this.color,c=this.vertices,u=a.gravity*e*e;a.getColor(ht,s,n,o),a.getAlpha(br,s,n,o),a.getTextureSlot(gr,s,n,o),c[1]-=u,c[4]-=u,l[0]=ht[0]*255,l[1]=ht[1]*255,l[2]=ht[2]*255,l[3]=br[0]*255,this.slot=gr[0]}}}class In extends bt{first=null;last=null;updateEmission(e){if(this.instance.allowParticleSpawn){const r=this.emitterObject;this.currentEmission+=r.emissionRate*e}}emit(){const e=this.emitObject(),t=this.last;t?(t.next=e,e.prev=t):this.first=e,this.last=e}kill(e){super.kill(e);const t=e.prev,r=e.next;e===this.first&&(this.first=r),e===this.last&&(this.first=null,this.last=null),t&&(t.next=r),r&&(r.prev=t),e.prev=null,e.next=null}createObject(){return new Ln(this)}}const xr=new Uint32Array(1);class gt extends bt{lastValue=0;updateEmission(e){const t=this.instance;if(t.allowParticleSpawn){this.emitterObject.getValue(xr,t);const s=xr[0];s===1&&s!==this.lastValue&&(this.currentEmission+=1),this.lastValue=s}}emit(){this.emitObject()}}class Pn extends ke{internalInstance;constructor(e){super(e);const r=e.emitterObject.internalModel;this.internalInstance=r.addInstance()}bind(){const e=this.emitter,t=e.instance,r=t.scene,s=t.nodes[e.emitterObject.index],n=this.internalInstance;n.setScene(r),n.setSequence(0),n.setTransformation(s.worldLocation,s.worldRotation,s.worldScale),n.show(),this.health=1}update(e){const t=this.internalInstance,r=t.model;t.frame>=r.sequences[0].interval[1]&&(this.health=0,t.hide())}}class Fn extends gt{createObject(){return new Pn(this)}}const J=M();class Qr extends ke{vertices=new Float32Array(12);bind(){const e=this.emitter,t=e.instance,r=e.emitterObject,s=this.vertices,n=r.scale,{worldLocation:o,worldRotation:a}=t.nodes[r.index];this.health=r.lifeSpan,_e(J,n,n,0),he(J,J,a),Te(s.subarray(0,2),J,o),_e(J,-n,n,0),he(J,J,a),Te(s.subarray(3,5),J,o),_e(J,-n,-n,0),he(J,J,a),Te(s.subarray(6,8),J,o),_e(J,n,-n,0),he(J,J,a),Te(s.subarray(9,11),J,o)}update(e){this.health-=e}}class On extends gt{createObject(){return new Qr(this)}}class Dn extends gt{createObject(){return new Qr(this)}}class Nn extends ke{bind(){const e=this.emitter,t=e.instance,r=t.model.viewer,s=t.scene;if(r.audioEnabled&&s.audioEnabled){const n=e.emitterObject,o=t.nodes[n.index],a=s.audioContext,l=n.decodedBuffers,c=a.createPanner(),u=a.createBufferSource(),h=o.worldLocation;c.positionX.value=h[0],c.positionY.value=h[1],c.positionZ.value=h[2],c.maxDistance=n.distanceCutoff,c.refDistance=n.minDistance,c.connect(a.destination),u.buffer=l[Math.random()*l.length|0],u.connect(c),u.start(0)}}update(e){}}class Vn extends gt{createObject(){return new Nn(this)}}const _r=new Float32Array(1),Et=M(),wt=$(),Tr=M(),ut=new Float32Array(3),ft=new Float32Array(1),Er=new Uint32Array(1);class Bn extends Rs{attachments=[];particleEmitters=[];particleEmitters2=[];ribbonEmitters=[];eventObjectEmitters=[];nodes=[];sortedNodes=[];frame=0;counter=0;sequence=-1;sequenceLoopMode=0;sequenceEnded=!1;teamColor=0;vertexColor=new Float32Array([1,1,1,1]);allowParticleSpawn=!1;forced=!0;geosetColors=[];layerAlphas=[];layerTextures=[];uvAnims=[];worldMatrices=null;boneTexture=null;constructor(e){super(e);for(let o=0,a=e.geosets.length;o<a;o++)this.geosetColors[o]=new Float32Array(4);for(let o=0,a=e.layers.length;o<a;o++)this.layerAlphas[o]=0,this.layerTextures[o]=0,this.uvAnims[o]=new Float32Array(5);const t=Ps(e.genericObjects.length,En),r=t.nodes;let s=0;this.nodes.push(...r),this.worldMatrices=t.worldMatrices;for(const o of e.bones)this.initNode(r,r[s++],o);for(const o of e.lights)this.initNode(r,r[s++],o);for(const o of e.helpers)this.initNode(r,r[s++],o);for(const o of e.attachments){let a;o.internalModel&&(a=new wn(this,o),this.attachments.push(a)),this.initNode(r,r[s++],o,a)}for(const o of e.particleEmitters){const a=new Rn(this,o);this.particleEmitters.push(a),this.initNode(r,r[s++],o,a)}for(const o of e.particleEmitters2){const a=new Mn(this,o);this.particleEmitters2.push(a),this.initNode(r,r[s++],o,a)}for(const o of e.ribbonEmitters){const a=new In(this,o);this.ribbonEmitters.push(a),this.initNode(r,r[s++],o,a)}for(const o of e.eventObjects){const a=o.type;let l;a==="SPN"?l=new Fn(this,o):a==="SPL"?l=new On(this,o):a==="UBR"?l=new Dn(this,o):l=new Vn(this,o),this.eventObjectEmitters.push(l),this.initNode(r,r[s++],o,l)}for(const o of e.collisionShapes)this.initNode(r,r[s++],o);const n=e.hierarchy;for(let o=0,a=r.length;o<a;o++)this.sortedNodes[o]=r[n[o]];e.bones.length&&(this.boneTexture=new Pr(e.viewer.gl,4,e.bones.length*4,1))}setTexture(e,t){this.overrideTexture(e,t)}setParticle2Texture(e,t){this.overrideTexture(Kr+e,t)}setEventTexture(e,t){this.overrideTexture(Ht+e,t)}clearEmittedObjects(){for(const e of this.particleEmitters)e.clear();for(const e of this.particleEmitters2)e.clear();for(const e of this.ribbonEmitters)e.clear();for(const e of this.eventObjectEmitters)e.clear()}initNode(e,t,r,s){oe(t.pivot,r.pivot),r.parentId===-1?t.parent=this:t.parent=e[r.parentId],t.dontInheritTranslation=r.dontInheritTranslation,t.dontInheritRotation=r.dontInheritRotation,t.dontInheritScaling=r.dontInheritScaling,r.billboarded?t.billboarded=!0:r.billboardedX?t.billboardedX=!0:r.billboardedY?t.billboardedY=!0:r.billboardedZ&&(t.billboardedZ=!0),s&&(t.object=s)}hide(){super.hide(),this.resetAttachments()}updateNodes(e,t){const r=this.sequence,s=this.frame,n=this.counter,o=this.sortedNodes,l=this.model.sortedGenericObjects;for(let c=0,u=o.length;c<u;c++){const h=l[c],f=o[c],d=f.parent;let m=t||d.wasDirty||h.anyBillboarding;const v=h.variants;(t||v.generic[r])&&(m=!0,(t||v.translation[r])&&h.getTranslation(f.localLocation,r,s,n),(t||v.rotation[r])&&h.getRotation(f.localRotation,r,s,n),(t||v.scale[r])&&h.getScale(f.localScale,r,s,n)),f.wasDirty=m,m&&f.recalculateTransformation(this),f.object&&(h.getVisibility(_r,r,s,n),_r[0]>0&&f.object.update(e));for(const p of f.children)m&&p.recalculateTransformation(),p.update(e)}}recalculateTransformation(){super.recalculateTransformation(),this.forced=!0}updateBatches(e){const t=this.sequence,r=this.frame,s=this.counter,n=this.model,o=n.geosets,a=n.layers,l=this.geosetColors,c=this.layerAlphas,u=this.layerTextures,h=this.uvAnims;for(let f=0,d=o.length;f<d;f++){const v=o[f].geosetAnimation,p=l[f];v?((e||v.variants.color[t])&&(v.getColor(ut,t,r,s),p[0]=ut[0],p[1]=ut[1],p[2]=ut[2]),(e||v.variants.alpha[t])&&(v.getAlpha(ft,t,r,s),p[3]=ft[0])):e&&(p[0]=1,p[1]=1,p[2]=1,p[3]=1)}for(let f=0,d=a.length;f<d;f++){const m=a[f],v=m.textureAnimation,p=h[f];(e||m.variants.alpha[t])&&(m.getAlpha(ft,t,r,s),c[f]=ft[0]),(e||m.variants.textureId[t])&&(m.getTextureId(Er,t,r,s),u[f]=Er[0]),v?((e||v.variants.translation[t])&&(v.getTranslation(Et,t,r,s),p[0]=Et[0],p[1]=Et[1]),(e||v.variants.rotation[t])&&(v.getRotation(wt,t,r,s),p[2]=wt[2],p[3]=wt[3]),(e||v.variants.scale[t])&&(v.getScale(Tr,t,r,s),p[4]=Tr[0])):e&&(p[0]=0,p[1]=0,p[2]=0,p[3]=1,p[4]=1)}}updateBoneTexture(){this.boneTexture&&this.boneTexture.bindAndUpdate(this.worldMatrices)}renderOpaque(){const e=this.model;for(const t of e.opaqueGroups)t.render(this)}renderTranslucent(){const e=this.model;for(const t of e.translucentGroups)t.render(this)}updateAnimations(e){const t=this.model,r=this.sequence;if(r!==-1){const n=t.sequences[r],o=n.interval,a=e*1e3;this.frame+=a,this.counter+=a,this.allowParticleSpawn=!0,this.frame>=o[1]?(this.sequenceLoopMode===2||this.sequenceLoopMode===0&&n.nonLooping===0?(this.frame=o[0],this.resetEventEmitters()):(this.frame=o[1],this.counter-=a,this.allowParticleSpawn=!1),this.sequenceEnded=!0):this.sequenceEnded=!1}const s=this.forced;(r!==-1||s)&&(this.updateNodes(e,s),this.updateBoneTexture(),this.updateBatches(s)),this.forced=!1}setTeamColor(e){return this.teamColor=e,this}setVertexColor(e){return this.vertexColor.set(e),this}setSequence(e){const r=this.model.sequences;return this.sequence=e,e<0||e>r.length-1?(this.sequence=-1,this.frame=0,this.allowParticleSpawn=!1):this.frame=r[e].interval[0],this.resetEventEmitters(),this.resetAttachments(),this.forced=!0,this}getBounds(){const e=this.model;if(this.sequence===-1)return e.bounds;const t=e.sequences[this.sequence].bounds;return t.r===0?e.bounds:t}setSequenceLoopMode(e){return this.sequenceLoopMode=e,this}getAttachment(e){const r=this.model.attachments[e];if(r)return this.nodes[r.index]}resetEventEmitters(){for(const e of this.eventObjectEmitters)e.lastValue=0}resetAttachments(){for(const e of this.attachments)e.internalInstance.hide()}}class Un extends As{reforged=!1;hd=!1;solverParams={};name="";sequences=[];globalSequences=[];materials=[];layers=[];textures=[];textureAnimations=[];geosets=[];geosetAnimations=[];bones=[];lights=[];helpers=[];attachments=[];pivotPoints=[];particleEmitters=[];particleEmitters2=[];ribbonEmitters=[];cameras=[];eventObjects=[];collisionShapes=[];hasLayerAnims=!1;hasGeosetAnims=!1;batches=[];genericObjects=[];sortedGenericObjects=[];hierarchy=[];opaqueGroups=[];translucentGroups=[];arrayBuffer=null;elementBuffer=null;skinDataType=0;bytesPerSkinElement=1;constructor(e,t){super(t);let r;if(e instanceof St)r=e;else{r=new St;try{r.load(e)}catch{}}const s=this.viewer,n=this.pathSolver,o=this.solverParams,a=r.version>800,l=a?".dds":".blp";let c=!1;this.reforged=a,this.name=r.name;const u=r.extent;this.bounds.fromExtents(u.min,u.max);for(const m of r.sequences)this.sequences.push(new Ds(m));for(const m of r.globalSequences)this.globalSequences.push(m);for(const m of r.textureAnimations)this.textureAnimations.push(new js(this,m));let h=0;for(const m of r.materials){const v=[];for(const p of m.layers){const b=new qs(this,p,h++,m.priorityPlane);v.push(b),this.layers.push(b)}this.materials.push(new Xs(this,m.shader,v)),m.shader!==""&&(this.hd=!0)}a&&(o.reforged=!0),this.hd&&(o.hd=!0);const f=r.textures;for(let m=0,v=f.length;m<v;m++){const p=f[m];let b=p.path;const g=p.replaceableId,E=p.wrapMode;b===""&&g!==0&&(b=`ReplaceableTextures\\${Ur[g]}${l}`,(g===1||g===2)&&(c=!0));const T=new Qe(g,E);s.load(b,n,o).then(_=>{_&&(T.texture=_)}),this.textures[m]=T}for(const m of r.geosetAnimations)this.geosetAnimations.push(new Ks(this,m));this.pivotPoints=r.pivotPoints;let d=0;for(const m of r.bones)this.bones.push(new Ys(this,m,d++));for(const m of r.lights)this.lights.push(new Ws(this,m,d++));for(const m of r.helpers)this.helpers.push(new $s(this,m,d++));for(const m of r.attachments)this.attachments.push(new Zs(this,m,d++));for(const m of r.particleEmitters)this.particleEmitters.push(new Qs(this,m,d++));for(const m of r.particleEmitters2){const v=new Wr(this,m,d++);this.particleEmitters2.push(v),v.teamColored&&(c=!0)}for(const m of r.ribbonEmitters)this.ribbonEmitters.push(new $r(this,m,d++));for(const m of r.cameras)this.cameras.push(new vn(this,m));for(const m of r.eventObjects)this.eventObjects.push(new pn(this,m,d++));for(const m of r.collisionShapes)this.collisionShapes.push(new bn(this,m,d++));this.genericObjects.push(...this.bones,...this.lights,...this.helpers,...this.attachments,...this.particleEmitters,...this.particleEmitters2,...this.ribbonEmitters,...this.eventObjects,...this.collisionShapes),xn(this,r.geosets),Tn(this),this.setupHierarchy(-1);for(let m=0,v=this.genericObjects.length;m<v;m++)this.sortedGenericObjects[m]=this.genericObjects[this.hierarchy[m]];c&&jt.loadTeamTextures(s)}addInstance(){return new Bn(this)}setupHierarchy(e){for(let t=0,r=this.genericObjects.length;t<r;t++){const s=this.genericObjects[t];s.parentId===e&&(this.hierarchy.push(t),this.setupHierarchy(s.objectId))}}}const Jr=`
#ifdef SKIN
attribute vec4 a_bones;
attribute vec4 a_weights;

void transformSkin(inout vec3 position, inout vec3 normal, inout vec3 tangent, inout vec3 binormal) {
  mat4 bone;

  bone += fetchMatrix(a_bones[0], 0.0) * a_weights[0];
  bone += fetchMatrix(a_bones[1], 0.0) * a_weights[1];
  bone += fetchMatrix(a_bones[2], 0.0) * a_weights[2];
  bone += fetchMatrix(a_bones[3], 0.0) * a_weights[3];

  mat3 rotation = mat3(bone);

  position = vec3(bone * vec4(position, 1.0));
  normal = rotation * normal;
  tangent = rotation * tangent;
  binormal = rotation * binormal;
}
#else
attribute vec4 a_bones;
#ifdef EXTENDED_BONES
attribute vec4 a_extendedBones;
#endif
attribute float a_boneNumber;

mat4 getVertexGroupMatrix() {
  mat4 bone;

  // For the broken models out there, since the game supports this.
  if (a_boneNumber > 0.0) {
    for (int i = 0; i < 4; i++) {
      if (a_bones[i] > 0.0) {
        bone += fetchMatrix(a_bones[i] - 1.0, 0.0);
      }
    }

    #ifdef EXTENDED_BONES
      for (int i = 0; i < 4; i++) {
        if (a_extendedBones[i] > 0.0) {
          bone += fetchMatrix(a_extendedBones[i] - 1.0, 0.0);
        }
      }
    #endif
  }

  return bone / a_boneNumber;
}

void transformVertexGroups(inout vec3 position, inout vec3 normal) {
  mat4 bone = getVertexGroupMatrix();
  mat3 rotation = mat3(bone);

  position = vec3(bone * vec4(position, 1.0));
  normal = normalize(rotation * normal);
}

void transformVertexGroupsHD(inout vec3 position, inout vec3 normal, inout vec3 tangent, inout vec3 binormal) {
  mat4 bone = getVertexGroupMatrix();
  mat3 rotation = mat3(bone);

  position = vec3(bone * vec4(position, 1.0));
  normal = normalize(rotation * normal);
  tangent = normalize(rotation * tangent);
  binormal = normalize(rotation * binormal);
}
#endif
`,Fe=`
uniform mat4 u_VP;
uniform vec3 u_lightPos;
uniform vec4 u_vertexColor;
uniform vec4 u_geosetColor;
uniform float u_layerAlpha;
uniform vec2 u_uvTrans;
uniform vec2 u_uvRot;
uniform float u_uvScale;
uniform bool u_hasBones;

attribute vec3 a_position;
attribute vec3 a_normal;
attribute vec2 a_uv;

varying vec2 v_uv;
varying vec3 v_normal;
varying vec4 v_color;
varying vec4 v_uvTransRot;
varying float v_uvScale;
varying vec3 v_lightDir;

${Vr}
${Jr}

void main() {
  vec3 position = a_position;
  vec3 normal = a_normal;

  if (u_hasBones) {
    #ifdef SKIN
      vec3 tangent = vec3(0.0);
      vec3 binormal = vec3(0.0);
      transformSkin(position, normal, tangent, binormal);
    #else
      transformVertexGroups(position, normal);
    #endif
  }

  v_uv = a_uv;
  v_normal = normal;
  v_color = u_vertexColor * u_geosetColor.bgra * vec4(1.0, 1.0, 1.0, u_layerAlpha);
  v_uvTransRot = vec4(u_uvTrans, u_uvRot);
  v_uvScale = u_uvScale;
  v_lightDir = normalize(u_lightPos - position);

  gl_Position = u_VP * vec4(position, 1.0);
}
`,Gn=`
// A 2D quaternion*vector.
// q is the zw components of the original quaternion.
vec2 quat_transform(vec2 q, vec2 v) {
  vec2 uv = vec2(-q.x * v.y, q.x * v.x);
  vec2 uuv = vec2(-q.x * uv.y, q.x * uv.x);

  return v + 2.0 * (uv * q.y + uuv);
}
`,Oe=`
${Vt}

${Gn}

uniform sampler2D u_texture;
uniform float u_filterMode;
uniform bool u_unshaded;

varying vec2 v_uv;
varying vec3 v_normal;
varying vec4 v_color;
varying vec4 v_uvTransRot;
varying float v_uvScale;
varying vec3 v_lightDir;

vec4 getDiffuseColor() {
  vec2 uv = v_uv;

  // Translation animation
  uv += v_uvTransRot.xy;

  // Rotation animation
  uv = quat_transform(v_uvTransRot.zw, uv - 0.5) + 0.5;

  // Scale animation
  uv = v_uvScale * (uv - 0.5) + 0.5;

  vec4 texel = texture2D(u_texture, uv);
  vec4 color = texel * v_color;

  // 1bit Alpha
  if (u_filterMode == 1.0 && color.a < 0.75) {
    discard;
  }

  // "Close to 0 alpha"
  if (u_filterMode >= 5.0 && color.a < 0.02) {
    discard;
  }

  return color;
}

void onlyTexCoords() {
  gl_FragColor = vec4(v_uv, 0.0, 1.0);
}

void onlyNormals() {
  gl_FragColor = vec4(v_normal, 1.0);
}

void onlyDiffuse() {
  gl_FragColor = getDiffuseColor();
}

void lambert() {
  vec4 color = getDiffuseColor();

  if (!u_unshaded) {
    float lambertFactor = clamp(dot(v_normal, v_lightDir), 0.0, 1.0);
    lambertFactor = clamp(lambertFactor + 0.7, 0.0, 1.0);

    color.rgb *= lambertFactor;
  }

  gl_FragColor = color;
}

void main() {
  #if defined(ONLY_DIFFUSE)
  onlyDiffuse();
  #elif defined(ONLY_TEXCOORDS)
  onlyTexCoords();
  #elif defined(ONLY_NORMALS)
  onlyNormals();
  #else
  lambert();
  #endif
}
`,se=`
uniform mat4 u_VP;
uniform mat4 u_MV;
uniform vec3 u_eyePos;
uniform vec3 u_lightPos;
uniform float u_layerAlpha;
uniform bool u_hasBones;

attribute vec3 a_position;
attribute vec3 a_normal;
attribute vec2 a_uv;
attribute vec4 a_tangent;

varying vec2 v_uv;
varying float v_layerAlpha;
varying vec3 v_lightDir;
varying vec3 v_eyeVec;
varying vec3 v_normal;
// varying vec3 v_lightDirWorld;

#if defined(ONLY_TANGENTS)
varying vec3 v_tangent;
#endif

${Vr}
${Jr}

vec3 TBN(vec3 vector, vec3 tangent, vec3 binormal, vec3 normal) {
  return vec3(dot(vector, tangent), dot(vector, binormal), dot(vector, normal));
}

void main() {
  vec3 position = a_position;
  vec3 normal = a_normal;
  vec3 tangent = a_tangent.xyz;

  // Re-orthogonalize the tangent in case it wasnt normalized.
  // See "One last thing" at https://learnopengl.com/Advanced-Lighting/Normal-Mapping
  tangent = normalize(tangent - dot(tangent, normal) * normal);

  vec3 binormal = cross(normal, tangent) * a_tangent.w;

  if (u_hasBones) {
    #ifdef SKIN
      transformSkin(position, normal, tangent, binormal);
    #else
      transformVertexGroupsHD(position, normal, tangent, binormal);
    #endif
  }

  vec3 position_mv = vec3(u_MV * vec4(position, 1));

  mat3 mv = mat3(u_MV);
  vec3 t = normalize(mv * tangent);
  vec3 b = normalize(mv * binormal);
  vec3 n = normalize(mv * normal);

  v_eyeVec = normalize(u_eyePos - position_mv);

  vec3 lightDir = normalize(u_lightPos - position_mv);
  v_lightDir = normalize(TBN(lightDir, t, b, n));
  
  v_uv = a_uv;
  v_layerAlpha = u_layerAlpha;

  v_normal = normal;
  // v_lightDirWorld = normalize(lightDir);

  #if defined(ONLY_TANGENTS)
  v_tangent = tangent;
  #endif

  gl_Position = u_VP * vec4(position, 1.0);
}
`,ne=`
${Vt}

uniform sampler2D u_diffuseMap;
uniform sampler2D u_normalsMap;
uniform sampler2D u_ormMap;
uniform sampler2D u_emissiveMap;
uniform sampler2D u_teamColorMap;
uniform sampler2D u_environmentMap;
uniform float u_filterMode;

// uniform sampler2D u_lutMap;
// uniform sampler2D u_envDiffuseMap;
// uniform sampler2D u_envSpecularMap;

varying vec2 v_uv;
varying float v_layerAlpha;
varying vec3 v_lightDir;
varying vec3 v_eyeVec;
varying vec3 v_normal;
// varying vec3 v_lightDirWorld;

#if defined(ONLY_TANGENTS)
varying vec3 v_tangent;
#endif

vec3 decodeNormal() {
  vec2 xy = texture2D(u_normalsMap, v_uv).xy * 2.0 - 1.0;
  
  return vec3(xy, sqrt(1.0 - dot(xy, xy)));
}

const vec2 invAtan = vec2(0.1591, 0.3183);
vec2 sampleEnvironmentMap(vec3 normal) {
  vec2 uv = vec2(atan(normal.x, normal.y), -asin(normal.z));
  uv *= invAtan;
  uv += 0.5;
  return uv;
}

vec4 getDiffuseColor() {
  vec4 color = texture2D(u_diffuseMap, v_uv);

  // 1bit Alpha
  if (u_filterMode == 1.0 && color.a < 0.75) {
    discard;
  }

  return color;
}

vec4 getOrmColor() {
  return texture2D(u_ormMap, v_uv);
}

vec3 getEmissiveColor() {
  return texture2D(u_emissiveMap, v_uv).rgb;
}

vec3 getTeamColor() {
  return texture2D(u_teamColorMap, v_uv).rgb;
}

// const float PI = 3.14159265359;
// const float RECIPROCAL_PI = 0.31830988618;
// const float RECIPROCAL_PI2 = 0.15915494;
// const float LN2 = 0.6931472;
// const float ENV_LODS = 6.0;
// vec4 SRGBtoLinear(vec4 srgb) {
//     vec3 linOut = pow(srgb.xyz, vec3(2.2));
//     return vec4(linOut, srgb.w);;
// }
// vec4 RGBMToLinear(in vec4 value) {
//     float maxRange = 6.0;
//     return vec4(value.xyz * value.w * maxRange, 1.0);
// }
// vec3 linearToSRGB(vec3 color) {
//     return pow(color, vec3(1.0 / 2.2));
// }
// // vec3 getNormal() {
// //     vec3 pos_dx = dFdx(vMPos.xyz);
// //     vec3 pos_dy = dFdy(vMPos.xyz);
// //     vec2 tex_dx = dFdx(vUv);
// //     vec2 tex_dy = dFdy(vUv);
// //     vec3 t = normalize(pos_dx * tex_dy.t - pos_dy * tex_dx.t);
// //     vec3 b = normalize(-pos_dx * tex_dy.s + pos_dy * tex_dx.s);
// //     mat3 tbn = mat3(t, b, normalize(vNormal));
// //     vec3 n = texture2D(tNormal, vUv * uNormalUVScale).rgb * 2.0 - 1.0;
// //     n.xy *= uNormalScale;
// //     vec3 normal = normalize(tbn * n);
// //     // Get world normal from view normal (normalMatrix * normal)
// //     return normalize((vec4(normal, 0.0) * viewMatrix).xyz);
// // }
// vec3 specularReflection(vec3 specularEnvR0, vec3 specularEnvR90, float VdH) {
//     return specularEnvR0 + (specularEnvR90 - specularEnvR0) * pow(clamp(1.0 - VdH, 0.0, 1.0), 5.0);
// }
// float geometricOcclusion(float NdL, float NdV, float roughness) {
//     float r = roughness;
//     float attenuationL = 2.0 * NdL / (NdL + sqrt(r * r + (1.0 - r * r) * (NdL * NdL)));
//     float attenuationV = 2.0 * NdV / (NdV + sqrt(r * r + (1.0 - r * r) * (NdV * NdV)));
//     return attenuationL * attenuationV;
// }
// float microfacetDistribution(float roughness, float NdH) {
//     float roughnessSq = roughness * roughness;
//     float f = (NdH * roughnessSq - NdH) * NdH + 1.0;
//     return roughnessSq / (PI * f * f);
// }
// vec2 cartesianToPolar(vec3 n) {
//     vec2 uv;
//     uv.x = atan(n.z, n.x) * RECIPROCAL_PI2 + 0.5;
//     uv.y = asin(n.y) * RECIPROCAL_PI + 0.5;
//     return uv;
// }
// void getIBLContribution(inout vec3 diffuse, inout vec3 specular, float NdV, float roughness, vec3 n, vec3 reflection, vec3 diffuseColor, vec3 specularColor) {
//   vec3 brdf = SRGBtoLinear(texture2D(u_lutMap, vec2(NdV, roughness))).rgb;
//   vec3 diffuseLight = RGBMToLinear(texture2D(u_envDiffuseMap, sampleEnvironmentMap(n))).rgb;
//   // Sample 2 levels and mix between to get smoother degradation
//   float blend = roughness * ENV_LODS;
//   float level0 = floor(blend);
//   float level1 = min(ENV_LODS, level0 + 1.0);
//   blend -= level0;
  
//   // Sample the specular env map atlas depending on the roughness value
//   vec2 uvSpec = sampleEnvironmentMap(reflection);
//   uvSpec.y /= 2.0;
//   vec2 uv0 = uvSpec;
//   vec2 uv1 = uvSpec;
//   uv0 /= pow(2.0, level0);
//   uv0.y += 1.0 - exp(-LN2 * level0);
//   uv1 /= pow(2.0, level1);
//   uv1.y += 1.0 - exp(-LN2 * level1);
//   vec3 specular0 = RGBMToLinear(texture2D(u_envSpecularMap, uv0)).rgb;
//   vec3 specular1 = RGBMToLinear(texture2D(u_envSpecularMap, uv1)).rgb;
//   vec3 specularLight = mix(specular0, specular1, blend);
//   diffuse = diffuseLight * diffuseColor;
  
//   // Bit of extra reflection for smooth materials
//   float reflectivity = pow((1.0 - roughness), 2.0) * 0.05;
//   specular = specularLight * (specularColor * brdf.x + brdf.y + reflectivity);
//   // specular *= uEnvSpecular;
// }

// void PBR() {
//   vec4 baseDiffuseColor = getDiffuseColor();
//   vec3 baseColor = baseDiffuseColor.rgb;
//   vec4 orm = getOrmColor();
//   vec3 tc = getTeamColor();
//   float tcFactor = getOrmColor().a;

//   if (tcFactor > 0.1) {
//     baseColor *= tc * tcFactor;
//   }

//   float roughness = clamp(orm.g, 0.04, 1.0);
//   float metallic = clamp(orm.b, 0.04, 1.0);

//   vec3 f0 = vec3(0.04);
//   vec3 diffuseColor = baseColor * (vec3(1.0) - f0) * (1.0 - metallic);
//   vec3 specularColor = mix(f0, baseColor, metallic);
//   vec3 specularEnvR0 = specularColor;
//   vec3 specularEnvR90 = vec3(clamp(max(max(specularColor.r, specularColor.g), specularColor.b) * 25.0, 0.0, 1.0));

//   vec3 N = v_normal;
//   vec3 V = normalize(v_eyeVec);
//   vec3 L = normalize(v_lightDirWorld);
//   vec3 H = normalize(L + V);
//   vec3 reflection = normalize(reflect(-V, N));

//   float NdL = clamp(dot(N, L), 0.001, 1.0);
//   float NdV = clamp(abs(dot(N, V)), 0.001, 1.0);
//   float NdH = clamp(dot(N, H), 0.0, 1.0);
//   float LdH = clamp(dot(L, H), 0.0, 1.0);
//   float VdH = clamp(dot(V, H), 0.0, 1.0);

//   vec3 F = specularReflection(specularEnvR0, specularEnvR90, VdH);
//   float G = geometricOcclusion(NdL, NdV, roughness);
//   float D = microfacetDistribution(roughness, NdH);

//   vec3 diffuseContrib = (1.0 - F) * (diffuseColor / PI);
//   vec3 specContrib = F * G * D / (4.0 * NdL * NdV);
  
//   // Shading based off lights
//   // vec3 color = NdL * uLightColor * (diffuseContrib + specContrib);
//   vec3 color = NdL * (diffuseContrib + specContrib);

//   // Calculate IBL lighting
//   vec3 diffuseIBL;
//   vec3 specularIBL;
//   getIBLContribution(diffuseIBL, specularIBL, NdV, roughness, N, reflection, diffuseColor, specularColor);

//   // Add IBL on top of color
//   color +=  specularIBL;

//   color *= orm.r;

//   color += getEmissiveColor();

//   // Convert to sRGB to display
//   gl_FragColor.rgb = color;
//   gl_FragColor.a = baseDiffuseColor.a;
// }

void onlyDiffuse() {
  vec4 baseColor = getDiffuseColor();
  vec3 tc = getTeamColor();
  float tcFactor = getOrmColor().a;

  if (tcFactor > 0.1) {
    baseColor.rgb *= tc * tcFactor;
  }

  gl_FragColor = baseColor;
}

void onlyNormalMap() {
  gl_FragColor = vec4(decodeNormal(), 1.0);
}

void onlyOcclusion() {
  gl_FragColor = vec4(getOrmColor().rrr, 1.0);
}

void onlyRoughness() {
  gl_FragColor = vec4(getOrmColor().ggg, 1.0);
}

void onlyMetallic() {
  gl_FragColor = vec4(getOrmColor().bbb, 1.0);
}

void onlyTeamColorFactor() {
  gl_FragColor = vec4(getOrmColor().aaa, 1.0);
}

void onlyEmissiveMap() {
  gl_FragColor = vec4(getEmissiveColor(), 1.0);
}

void onlyTexCoords() {
  gl_FragColor = vec4(v_uv, 0.0, 1.0);
}

void onlyNormals() {
  gl_FragColor = vec4(v_normal, 1.0);
}

#if defined(ONLY_TANGENTS)
void onlyTangents() {
  gl_FragColor = vec4(v_tangent, 1.0);
}
#endif

void lambert() {
  vec4 baseColor = getDiffuseColor();
  vec3 normal = decodeNormal();
  vec4 orm = getOrmColor();
  vec3 emissive = getEmissiveColor();
  vec3 tc = getTeamColor();
  float aoFactor = orm.r;
  float tcFactor = orm.a;
  float lambertFactor = clamp(dot(normal, v_lightDir), 0.0, 1.0);
  vec3 color = baseColor.rgb;

  if (tcFactor > 0.1) {
    color *= tc * tcFactor;
  }
  
  color *= clamp(lambertFactor * aoFactor + 0.1, 0.0, 1.0);
  color += emissive;

  gl_FragColor = vec4(color, baseColor.a);
}

void main() {
  #if defined(ONLY_DIFFUSE)
  onlyDiffuse();
  #elif defined(ONLY_NORMAL_MAP)
  onlyNormalMap();
  #elif defined(ONLY_OCCLUSION)
  onlyOcclusion();
  #elif defined(ONLY_ROUGHNESS)
  onlyRoughness();
  #elif defined(ONLY_METALLIC)
  onlyMetallic();
  #elif defined(ONLY_TC_FACTOR)
  onlyTeamColorFactor();
  #elif defined(ONLY_EMISSIVE)
  onlyEmissiveMap();
  #elif defined(ONLY_TEXCOORDS)
  onlyTexCoords();
  #elif defined(ONLY_NORMALS)
  onlyNormals();
  #elif defined(ONLY_TANGENTS)
  onlyTangents();
  #else
  lambert();
  #endif
}
`,kn=`
#define EMITTER_PARTICLE2 0
#define EMITTER_RIBBON 1
#define EMITTER_SPLAT 2
#define EMITTER_UBERSPLAT 3
#define HEAD 0.0

uniform mat4 u_VP;
uniform int u_emitter;

// Shared
uniform vec4 u_colors[3];
uniform vec3 u_vertices[4];
uniform vec3 u_intervals[4];
uniform float u_lifeSpan;
uniform float u_columns;
uniform float u_rows;

// Particle2
uniform vec3 u_scaling;
uniform vec3 u_cameraZ;
uniform float u_timeMiddle;
uniform bool u_teamColored;

// Splat and Uber.
uniform vec3 u_intervalTimes;

// Vertices
attribute float a_position;

// Instances
attribute vec3 a_p0;
attribute vec3 a_p1;
attribute vec3 a_p2;
attribute vec3 a_p3;
attribute float a_health;
attribute vec4 a_color;
attribute float a_tail;
attribute vec3 a_leftRightTop;

varying vec2 v_texcoord;
varying vec4 v_color;

float getCell(vec3 interval, float factor) {
  float start = interval[0];
  float end = interval[1];
  float repeat = interval[2];
  float spriteCount = end - start;

  if (spriteCount > 0.0) {
    // Repeating speeds up the sprite animation, which makes it effectively run N times in its interval.
    // E.g. if repeat is 4, the sprite animation will be seen 4 times, and thus also run 4 times as fast.
    // The sprite index is limited to the number of actual sprites.
    return min(start + mod(floor(spriteCount * repeat * factor), spriteCount), u_columns * u_rows - 1.0);
  }

  return start;
}

void particle2() {
  float factor = (u_lifeSpan - a_health) / u_lifeSpan;
  int index = 0;

  if (factor < u_timeMiddle) {
    factor = factor / u_timeMiddle;
    index = 0;
  } else {
    factor = (factor - u_timeMiddle) / (1.0 - u_timeMiddle);
    index = 1;
  }

  factor = min(factor, 1.0);

  float scale = mix(u_scaling[index], u_scaling[index + 1], factor);
  vec4 color = mix(u_colors[index], u_colors[index + 1], factor);

  float cell = 0.0;

  if (u_teamColored) {
    cell = a_leftRightTop[0];
  } else {
    vec3 interval;

    if (a_tail == HEAD) {
      interval = u_intervals[index];
    } else {
      interval = u_intervals[index + 2];
    }

    cell = getCell(interval, factor);
  }

  float left = floor(mod(cell, u_columns));
  float top = floor(cell / u_columns);
  float right = left + 1.0;
  float bottom = top + 1.0;

  left /= u_columns;
  right /= u_columns;
  top /= u_rows;
  bottom /= u_rows;

  if (a_position == 0.0) {
    v_texcoord = vec2(right, top);
  } else if (a_position == 1.0) {
    v_texcoord = vec2(left, top);
  } else if (a_position == 2.0) {
    v_texcoord = vec2(left, bottom);
  } else if (a_position == 3.0) {
    v_texcoord = vec2(right, bottom);
  }

  v_color = color;
  
  if (a_tail == HEAD) {
    vec3 v = u_vertices[int(a_position)];
    float cs = cos(a_p1.x);
    float sn = sin(a_p1.x);

    float x = v.x * cs - v.y * sn;
    float y = v.x * sn + v.y * cs;

    vec3 fv = vec3(
      v.x * cs - v.y * sn,
      v.x * sn + v.y * cs,
      v.z);

    gl_Position = u_VP * vec4(a_p0 + fv * scale, 1.0);
  } else {
    // Get the normal to the tail in camera space.
    // This allows to build a 2D rectangle around the 3D tail.
    vec3 normal = cross(u_cameraZ, normalize(a_p1 - a_p0));
    vec3 boundary = normal * scale * a_p2[0];
    vec3 position;

    if (a_position == 0.0) {
      position = a_p0 - boundary;
    } else if (a_position == 1.0) {
      position = a_p1 - boundary;
    } else if (a_position == 2.0) {
      position = a_p1 + boundary;
    } else if (a_position == 3.0) {
      position = a_p0 + boundary;
    }

    gl_Position = u_VP * vec4(position, 1.0);
  }
}

void ribbon() {
  vec3 position;
  float left = a_leftRightTop[0] / 255.0;
  float right = a_leftRightTop[1] / 255.0;
  float top = a_leftRightTop[2] / 255.0;
  float bottom = top + 1.0;

  if (a_position == 0.0) {
    v_texcoord = vec2(right, top);
    position = a_p0;
  } else if (a_position == 1.0) {
    v_texcoord = vec2(right, bottom);
    position = a_p1;
  } else if (a_position == 2.0) {
    v_texcoord = vec2(left, bottom);
    position = a_p2;
  } else if (a_position == 3.0) {
    v_texcoord = vec2(left, top);
    position = a_p3;
  }

  v_texcoord[0] /= u_columns;
  v_texcoord[1] /= u_rows;

  v_color = a_color;

  gl_Position = u_VP * vec4(position, 1.0);
}

void splat() {
  float factor = u_lifeSpan - a_health;
  int index;

  if (factor < u_intervalTimes[0]) {
    factor = factor / u_intervalTimes[0];
    index = 0;
  } else {
    factor = (factor - u_intervalTimes[0]) / u_intervalTimes[1];
    index = 1;
  }

  float cell = getCell(u_intervals[index], factor);
  float left = floor(mod(cell, u_columns));
  float top = floor(cell / u_columns);
  float right = left + 1.0;
  float bottom = top + 1.0;
  vec3 position;

  if (a_position == 0.0) {
    v_texcoord = vec2(left, top);
    position = a_p0;
  } else if (a_position == 1.0) {
    v_texcoord = vec2(left, bottom);
    position = a_p1;
  } else if (a_position == 2.0) {
    v_texcoord = vec2(right, bottom);
    position = a_p2;
  } else if (a_position == 3.0) {
    v_texcoord = vec2(right, top);
    position = a_p3;
  }

  v_texcoord[0] /= u_columns;
  v_texcoord[1] /= u_rows;

  v_color = mix(u_colors[index], u_colors[index + 1], factor) / 255.0;

  gl_Position = u_VP * vec4(position, 1.0);
}

void ubersplat() {
  float factor = u_lifeSpan - a_health;
  vec4 color;

  if (factor < u_intervalTimes[0]) {
    color = mix(u_colors[0], u_colors[1], factor / u_intervalTimes[0]);
  } else if (factor < u_intervalTimes[0] + u_intervalTimes[1]) {
    color = u_colors[1];
  } else {
    color = mix(u_colors[1], u_colors[2], (factor - u_intervalTimes[0] - u_intervalTimes[1]) / u_intervalTimes[2]);
  }

  vec3 position;

  if (a_position == 0.0) {
    v_texcoord = vec2(0.0, 0.0);
    position = a_p0;
  } else if (a_position == 1.0) {
    v_texcoord = vec2(0.0, 1.0);
    position = a_p1;
  } else if (a_position == 2.0) {
    v_texcoord = vec2(1.0, 1.0);
    position = a_p2;
  } else if (a_position == 3.0) {
    v_texcoord = vec2(1.0, 0.0);
    position = a_p3;
  }

  v_color = color / 255.0;

  gl_Position = u_VP * vec4(position, 1.0);
}

void main() {
  if (u_emitter == EMITTER_PARTICLE2) {
    particle2();
  } else if (u_emitter == EMITTER_RIBBON) {
    ribbon();
  } else if (u_emitter == EMITTER_SPLAT) {
    splat();
  } else if (u_emitter == EMITTER_UBERSPLAT) {
    ubersplat();
  }
}
`,Hn=`
${Vt}

#define EMITTER_PARTICLE2 0
#define EMITTER_RIBBON 1

uniform sampler2D u_texture;
uniform highp int u_emitter;
uniform float u_filterMode;

varying vec2 v_texcoord;
varying vec4 v_color;

void main() {
  vec4 texel = texture2D(u_texture, v_texcoord);
  vec4 color = texel * v_color;

  // 1bit Alpha, used by ribbon emitters.
  if (u_emitter == EMITTER_RIBBON && u_filterMode == 1.0 && color.a < 0.75) {
    discard;
  }

  // "Close to 0 alpha"
  if (u_emitter == EMITTER_PARTICLE2 && (u_filterMode == 2.0 || u_filterMode == 3.0) && color.a < 0.02) {
    discard;
  }

  // Alpha key.
  if (u_emitter == EMITTER_PARTICLE2 && (u_filterMode == 4.0) && color.a < 0.75) {
    discard;
  }

  gl_FragColor = color;
}
`,jn=i=>new Os(i),zn=i=>Fs(i),jt={load(i,e,t=!1){const r=i.gl,s=i.webgl;if(!s.ensureExtension("OES_texture_float"))throw new Error("MDX: No float texture support!");if(!s.ensureExtension("ANGLE_instanced_arrays"))throw new Error("MDX: No instanced rendering support!");const n=`#define EXTENDED_BONES
`+Fe,o=`#define ONLY_DIFFUSE
`+Oe,a=`#define ONLY_TEXCOORDS
`+Oe,l=`#define ONLY_NORMALS
`+Oe,c=`#define EXTENDED_BONES
`+se,u=`#define SKIN
`+se,h=`#define ONLY_DIFFUSE
`+ne,f=`#define ONLY_NORMAL_MAP
`+ne,d=`#define ONLY_OCCLUSION
`+ne,m=`#define ONLY_ROUGHNESS
`+ne,v=`#define ONLY_METALLIC
`+ne,p=`#define ONLY_TC_FACTOR
`+ne,b=`#define ONLY_EMISSIVE
`+ne,g=`#define ONLY_TEXCOORDS
`+ne,E=`#define ONLY_NORMALS
`+ne,T=`#define ONLY_TANGENTS
`+ne,_=s.createShader(Fe,Oe),x=s.createShader(n,Oe),L=`#define SKIN
`+Fe,F=s.createShader(L,Oe),V=s.createShader(se,ne),N=s.createShader(c,ne),k=s.createShader(u,ne),C=s.createShader(kn,Hn),B=[],R=[];let w=[];w[P.Diffuse]=s.createShader(Fe,o),w[P.TexCoords]=s.createShader(Fe,a),w[P.Normals]=s.createShader(Fe,l),B[K.VertexGroups]=w,w=[],w[P.Diffuse]=s.createShader(n,o),w[P.TexCoords]=s.createShader(n,a),w[P.Normals]=s.createShader(n,l),B[K.ExtendedVertexGroups]=w,w=[],w[P.Diffuse]=s.createShader(se,h),w[P.NormalMap]=s.createShader(se,f),w[P.Occlusion]=s.createShader(se,d),w[P.Roughness]=s.createShader(se,m),w[P.Metallic]=s.createShader(se,v),w[P.TCFactor]=s.createShader(se,p),w[P.Emissive]=s.createShader(se,b),w[P.TexCoords]=s.createShader(se,g),w[P.Normals]=s.createShader(se,E),w[P.Tangents]=s.createShader(`#define ONLY_TANGENTS
`+se,T),R[K.VertexGroups]=w,w=[],w[P.Diffuse]=s.createShader(c,h),w[P.NormalMap]=s.createShader(c,f),w[P.Occlusion]=s.createShader(c,d),w[P.Roughness]=s.createShader(c,m),w[P.Metallic]=s.createShader(c,v),w[P.TCFactor]=s.createShader(c,p),w[P.Emissive]=s.createShader(c,b),w[P.TexCoords]=s.createShader(c,g),w[P.Normals]=s.createShader(c,E),w[P.Tangents]=s.createShader(`#define ONLY_TANGENTS
`+c,T),R[K.ExtendedVertexGroups]=w,w=[],w[P.Diffuse]=s.createShader(u,h),w[P.NormalMap]=s.createShader(u,f),w[P.Occlusion]=s.createShader(u,d),w[P.Roughness]=s.createShader(u,m),w[P.Metallic]=s.createShader(u,v),w[P.TCFactor]=s.createShader(u,p),w[P.Emissive]=s.createShader(u,b),w[P.TexCoords]=s.createShader(u,g),w[P.Normals]=s.createShader(u,E),w[P.Tangents]=s.createShader(`#define ONLY_TANGENTS
`+u,T),R[K.Skin]=w;const U=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,U),r.bufferData(r.ARRAY_BUFFER,new Uint8Array([0,1,2,0,2,3]),r.STATIC_DRAW);const y={pathSolver:e,reforged:t,sdShader:_,sdSkinShader:F,sdExtendedShader:x,hdShader:V,hdExtendedShader:N,hdSkinShader:k,particlesShader:C,sdDebugShaders:B,hdDebugShaders:R,rectBuffer:U,teamColors:[],teamGlows:[],eventObjectTables:{}};i.sharedCache.set("mdx",y)},isValidSource(i){return i instanceof St?!0:ci(i)||hi(i)},resource:Un,loadTeamTextures(i){const{pathSolver:e,reforged:t,teamColors:r,teamGlows:s}=i.sharedCache.get("mdx");if(r.length===0){const n=t?28:16,o=t?"dds":"blp",a=t?{reforged:!0}:void 0;for(let l=0;l<n;l++){const u=`${`${l}`.padStart(2,"0")}.${o}`,h=new Qe(1,Ve.WrapBoth),f=new Qe(2,Ve.WrapBoth);i.load(`ReplaceableTextures\\TeamColor\\TeamColor${u}`,e,a).then(d=>h.texture=d),i.load(`ReplaceableTextures\\TeamGlow\\TeamGlow${u}`,e,a).then(d=>f.texture=d),r[l]=h,s[l]=f}}},getEventObjectSoundFile(i,e,t,r){if(!e||ni(i)===".flac")return i;for(let s=1,n=r.length;s<n;s++){const o=r[s].data.getRow(i);if(o){const a=o.string("Flags"),l=o.string("Filepath");if(a==="SD_ONLY"){if(!t)return l}else if(a==="HD_ONLY"){if(t)return l}else return l}}},async getEventObjectData(i,e,t,r){if(e!=="SPN"&&e!=="SPL"&&e!=="UBR"&&e!=="SND")return;const{pathSolver:s,reforged:n,eventObjectTables:o}=i.sharedCache.get("mdx"),a=n?{reforged:!0}:{},l=(d,m)=>s?s(d,m):d;if(!o[e]){const d=[];e==="SPN"?d.push("Splats\\SpawnData.slk"):e==="SPL"?d.push("Splats\\SplatData.slk"):e==="UBR"?d.push("Splats\\UberSplatData.slk"):e==="SND"&&(d.push("UI\\SoundInfo\\AnimSounds.slk"),n?d.push("UI\\SoundInfo\\DialogueHumanBase.slk","UI\\SoundInfo\\DialogueOrcBase.slk","UI\\SoundInfo\\DialogueUndeadBase.slk","UI\\SoundInfo\\DialogueNightElfBase.slk","UI\\SoundInfo\\DialogueNagaBase.slk","UI\\SoundInfo\\DialogueDemonBase.slk","UI\\SoundInfo\\DialogueCreepsBase.slk"):d.push("UI\\SoundInfo\\AnimLookups.slk"));const m=d.map(p=>i.loadGeneric(l(p,a),"text",jn)),v=await Promise.all(m);for(const p of v)if(!p)return;o[e]=v}const c=o[e],u=c[0].data;let h;const f=[];if(e==="SND"){if(n)h=u.findRow("AnimationEventCode",t);else{const d=c[1].data.getRow(t);d&&(h=u.getRow(d.string("SoundLabel")))}if(h)for(const d of h.string("FileNames").split(",")){const m=this.getEventObjectSoundFile(d,n,r,c);m&&f.push(i.loadGeneric(l(m,a),"arrayBuffer",zn))}}else h=u.getRow(t),h&&(e==="SPN"?f.push(i.load(h.string("Model").replace(".mdl",".mdx"),l,a)):(e==="SPL"||e==="UBR")&&f.push(i.load(`ReplaceableTextures\\Splats\\${h.string("file")}${n?".dds":".blp"}`,l,a)));if(h&&f.length){const m=(await Promise.all(f)).filter(v=>v);if(m.length)return{row:h,resources:m}}},getBatchShader(i,e,t){const r=i.sharedCache.get("mdx"),s=i.debugRenderMode;if(t){if(s!==P.None){const n=r.hdDebugShaders[e];if(n){const o=n[s];if(o)return o}}return e===K.Skin?r.hdSkinShader:e===K.VertexGroups?r.hdShader:r.hdExtendedShader}else{if(s!==P.None){const n=r.sdDebugShaders[e];if(n){const o=n[s];if(o)return o}}return e===K.Skin?r.sdSkinShader:e===K.VertexGroups?r.sdShader:r.sdExtendedShader}}};export{Be as A,Rt as B,Yt as C,dt as D,Ai as E,Pt as F,ps as G,Ps as H,Ce as I,Rs as J,Pr as K,Lt as L,Jn as M,Qi as N,Nr as S,Or as T,Ze as V,Os as a,eo as b,M as c,Ne as d,$ as e,Zt as f,_e as g,Ke as h,Zn as i,Un as j,As as k,Te as l,jt as m,yt as n,vt as o,Mi as p,Ti as q,oe as r,Vt as s,we as t,It as u,yr as v,Sr as w,he as x,Vr as y,zi as z};
