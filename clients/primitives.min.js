import{c as v,M as l,T as x,L as F,d as b,e as R,f as O,B as G}from"./model.min.js";function L(s,e,t){let u,f,y,a=v.Unshaded;t&&(u=t.lines,f=t.color,y=t.texture,t.twoSided&&(a|=v.TwoSided));const r=new l,A=r.extent,n=e.boundingRadius;A.min.fill(-n),A.max.fill(n),A.boundsRadius=n;const d=new x;d.path="PLACEHOLDER",r.textures[0]=d;const i=U=>U===r?r:y,c=new b,g=new F;g.textureId=0,g.flags=a,c.layers[0]=g,r.materials[0]=c;const o=new R;o.vertices=e.vertices,o.uvSets[0]=e.uvs,o.matrixGroups=new Uint32Array([1]),o.matrixIndices=new Uint32Array([0]),o.vertexGroups=new Uint8Array(e.vertices.length/3);let w=4,h=e.faces;if(u&&(w=1,h=e.edges),o.faceTypeGroups=new Uint32Array([w]),o.faceGroups=new Uint32Array([h.length]),o.faces=h,r.geosets[0]=o,f){const U=new O;U.geosetId=0,U.color=f,r.geosetAnimations[0]=U}const M=new G;return M.objectId=0,r.bones[0]=M,s.load(r,i)}function I(s,e){return{vertices:new Float32Array([-s,e,0,-s,-e,0,s,-e,0,s,e,0]),uvs:new Float32Array([0,0,0,1,1,1,1,0]),faces:new Uint16Array([0,1,2,0,2,3]),edges:new Uint16Array([0,1,1,2,2,3,3,0]),boundingRadius:Math.hypot(s,e)}}function H(){return I(1,1)}function T(s,e,t){return{vertices:new Float32Array([-s,-e,-t,-s,-e,t,-s,e,-t,-s,e,t,s,e,-t,s,e,t,s,-e,-t,s,-e,t]),uvs:new Float32Array([0,0,0,1,.25,0,.25,1,.5,0,.5,1,.75,0,.75,1]),faces:new Uint16Array([0,1,2,1,3,2,2,3,4,3,5,4,4,5,6,5,7,6,6,7,0,7,1,0,0,2,4,0,4,6,1,5,3,1,7,5]),edges:new Uint16Array([0,1,2,3,4,5,6,7,0,2,2,4,4,6,6,0,1,3,3,5,5,7,7,1]),boundingRadius:Math.hypot(s,e,t)}}function B(){return T(1,1,1)}function m(s,e,t){const u=(e+1)*(t+1),f=new Float32Array(u*3),y=new Float32Array(u*2),a=new Uint16Array(e*t*6),r=new Uint16Array(e*t*6);for(let A=0,n=0,d=0;A<=e;A++){const i=A*Math.PI/e,c=Math.sin(i),g=Math.cos(i);for(let o=0;o<=t;o+=1,n+=3,d+=2){const w=o*2*Math.PI/t,h=Math.sin(w),M=Math.cos(w);f[n+0]=M*c*s,f[n+1]=h*c*s,f[n+2]=g*s,y[d+0]=o/t,y[d+1]=1-A/e}}for(let A=0,n=0;A<e;A++)for(let d=0;d<t;d+=1,n+=6){const i=A*(t+1)+d,c=i+t+1;a[n+0]=i,a[n+1]=c,a[n+2]=i+1,a[n+3]=c,a[n+4]=c+1,a[n+5]=i+1,r[n+0]=i,r[n+1]=c,r[n+2]=i,r[n+3]=i+1,r[n+4]=c,r[n+5]=c+1}return{vertices:f,uvs:y,faces:a,edges:r,boundingRadius:s}}function E(s,e){return m(1,s,e)}function S(s,e,t){t=Math.max(t,3);const u=(t+1)*2+2,f=new Float32Array(u*3),y=new Float32Array(u*2),a=new Uint16Array(t*12),r=new Uint16Array(t*10),A=Math.PI*2/t;let n=0,d=0;for(let i=0;i<t+1;i+=1,n+=6,d+=4){const c=Math.cos(A*i)*s,g=Math.sin(A*i)*s,o=i/t;f[n+0]=c,f[n+1]=g,f[n+2]=e,f[n+3]=c,f[n+4]=g,f[n+5]=-e,y[d+0]=o,y[d+1]=1,y[d+2]=o,y[d+3]=0}f[n+0]=0,f[n+1]=0,f[n+2]=e,f[n+3]=0,f[n+4]=0,f[n+5]=-e,y[d+0]=0,y[d+1]=1,y[d+2]=0,y[d+3]=0;for(let i=0,c=0,g=0;i<t;i+=1,c+=12,g+=10){const o=i*2;a[c+0]=o+0,a[c+1]=o+1,a[c+2]=(o+3)%(u-2),a[c+3]=o+0,a[c+4]=(o+3)%(u-2),a[c+5]=(o+2)%(u-2),a[c+6]=o+0,a[c+7]=(o+2)%(u-2),a[c+8]=u-2,a[c+9]=o+1,a[c+10]=(o+3)%(u-2),a[c+11]=u-1,r[g+0]=o+0,r[g+1]=o+1,r[g+2]=o+0,r[g+3]=(o+2)%(u-2),r[g+4]=o+1,r[g+5]=(o+3)%(u-2),r[g+6]=o+0,r[g+7]=u-2,r[g+8]=o+1,r[g+9]=u-1}return{vertices:f,uvs:y,faces:a,edges:r,boundingRadius:Math.hypot(s,e)}}function W(s){return S(1,1,s)}function j(s,e,t,u){const f=2*Math.tan(s/2),y=f*t/2,a=t*e/2,r=f*u/2,A=u*e/2;return{vertices:new Float32Array([-a,-y,t,-a,y,t,-A,-r,u,-A,r,u,A,-r,u,A,r,u,a,-y,t,a,y,t]),uvs:new Float32Array([0,0,0,1,.25,0,.25,1,.5,0,.5,1,.75,0,.75,1]),faces:new Uint16Array([0,1,2,1,3,2,2,3,4,3,5,4,4,5,6,5,7,6,6,7,0,7,1,0,0,2,4,0,4,6,1,5,3,1,7,5]),edges:new Uint16Array([0,1,2,3,4,5,6,7,0,2,2,4,4,6,6,0,1,3,3,5,5,7,7,1]),boundingRadius:Math.hypot(A,r)}}export{H as a,B as b,L as c,E as d,W as e,j as f};
